# 学习路线

1. 介绍
    C#是由微软开发的一种强类型、面向对象的编程语言，主要用于.NET框架，C#在企业级开发中非常流行，并且它也被广泛应用于桌面应用、网络服务器、游戏开发（特别是使用Unity引擎）等领域。

学习C#通常会遵循以下路径：

2. C#基础
环境搭建：安装Visual Studio或Visual Studio Code，配置.NET环境。
基本语法：学习C#数据类型、变量、运算符、控制流程（if, else, switch, loops）等。
面向对象编程：掌握类、对象、继承、多态性、封装等OOP基础概念。
异常处理：了解如何处理和抛出异常。
集合：学习List、Dictionary、HashSet等集合的使用。
委托和事件：理解C#中委托的概念，以及如何使用事件。
3. 进阶技术
LINQ(Language Integrated Query)：学习LINQ查询语法，它允许对数据进行查询、筛选、排序等操作。
异步编程：理解async和await关键词，学习怎样编写异步代码来提升应用性能。
反射：了解并使用反射来在运行时获取类型信息和操作对象。
泛型：学习泛型的概念和用法，理解其如何提高代码的复用性和性能。
属性和索引器：学习属性和索引器的概念，了解如何使用它们封装类的数据。
4. .NET框架核心
.NET CLI和项目结构：熟悉.NET命令行工具和项目文件（.csproj）结构。
Dependency Injection (DI)：学习依赖注入的概念及其在.NET中的实现。
Entity Framework Core：学习使用Entity Framework Core进行数据库的ORM映射和操作。
MVC/MVVM架构：学习使用ASP.NET Core MVC构建Web应用程序，或使用MVVM模式构建WPF/UWP应用程序。
5. 前端和桌面应用开发
Blazor：了解如何使用Blazor(WebAssembly或Server)开发Web前端应用程序。
WPF/WinForms：学习Windows Presentation Foundation或Windows Forms进行桌面应用开发。
Xamarin：了解如何使用Xamarin开发跨平台的移动应用。
6. Web 后端开发
ASP.NET Core：学习构建Web API和动态Web应用程序。
信号R(SignalR)：了解如何使用SignalR实现实时通信。
Web服务：学习创建和使用SOAP和RESTful Web服务。
7. 游戏开发
Unity编程：学习C#在Unity游戏引擎中的用法，制作2D或3D游戏。
8. 软件开发实践
版本控制：掌握Git等版本控制系统的使用。
单元测试：学习编写单元测试以及使用NUnit或xUnit测试框架。
CI/CD：学习持续集成和持续部署的流程和工具，如Azure DevOps。
设计模式：学习常见的设计模式，并了解它们在C#中的应用。
9. 性能调优和最佳实践
代码分析工具：使用Roslyn analyzers、Profiler等工具优化代码。
内存管理：理解垃圾回收机制以及如何管理和优化内存使用。
10. 实战经验
项目实践：通过构建实际的项目，将学到的知识运用到实际编码中。
开源贡献：参与开源项目可以提高你的编程技巧并了解更多的实际开发流程。
11. 持续学习
阅读文档和书籍：如《C# in Depth》、《Pro C# 9 with .NET 5》等。
加入社区：参加C#相关的会议、论坛、社交媒体小组等，与其他开发者学习和交流。
保持更新：跟上C#和.NET的最新动态，学习并实践最新的工具和框架。

# 视频学习

## 环境搭建

下载vs2022

Pro（专业版）:　TD244-P4NB7-YQ6XK-Y8MMM-YWV2J 

激活码企业版：

VHF9H-NXBBB-638P6-6JHCY-88JWH 



其他版本Visual Studio密钥：　

VS2019专业版和企业版的密钥：　　

Visual Studio 2019 Enterprise（企业版）:BF8Y8-GN2QH-T84XB-QVY3B-RC4DF　　

Visual Studio 2019 Professional（专业版）:NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y



VS2017专业版和企业版的密钥：

Visual Studio 2017 Enterprise（企业版）:NJVYC-BMHX2-G77MM-4XJMR-6Q8QF　　Visual Studio 2019 Professional（专业版）:KBJFW-NXHK6-W4WJM-CRMQB-G3CDH



VS2015专业版和企业版的密钥

Visual Studio 2015 Enterprise（企业版）:HM6NR-QXX7C-DFW2Y-8B82K-WTYJV　Visual Studio 2015 Professional （专业版）:HMGNV-WCYXV-X7G9W-YCX63-B98R2

VS2013高级版、专业版和旗舰版的密钥 ：

　Visual Studio 2013 Ultimate（旗舰版）:BWG7X-J98B3-W34RT-33B3R-JVYW9

　Visual Studio 2013 Premium（高级版）:FBJVC-3CMTX-D8DVP-RTQCT-92494

　　Visual Studio 2013 Professional（专业版）:XDM3T-W3T3V-MGJWK-8BFVD-GVPKY



VS2012高级版、专业版和旗舰版的密钥

　　Visual Studio 2012 Ultimate（旗舰版）:YKCW6-BPFPF-BT8C9-7DCTH-QXGWC

　Visual Studio 2012 Premium（高级版）:MH2FR-BC9R2-84433-47M63-KQVWC

　Visual Studio 2012 Professional（专业版）:4D974-9QX42-9Y43G-YJ7JG-JDYBP



VS2010旗舰版、专业版和高级版的密钥

Visual Studio 2010 :YCFHQ-9DWCY-DKV88-T2TMH-G7BHP 



创建新项目D:\code\Csharp\

![image-20240509144957139](D:\stu\java\java markdown\image\image-20240509144957139.png)

# C# 基础

菜鸟

https://www.runoob.com/csharp/csharp-tutorial.html

![image-20240509151715054](D:\stu\java\java markdown\image\image-20240509151715054.png)

- 程序的第一行 **using System;** - **using** 关键字用于在程序中包含 **System** 命名空间。 一个程序一般有多个 **using** 语句。

- 下一行是 **namespace** 声明。一个 **namespace** 里包含了一系列的类。*HelloWorldApplication* 命名空间包含了类 *HelloWorld*。

- 下一行是 **class** 声明。类 *HelloWorld* 包含了程序使用的数据和方法声明。类一般包含多个方法。方法定义了类的行为。在这里，*HelloWorld* 类只有一个 **Main** 方法。

- 下一行定义了 **Main** 方法，是所有 C# 程序的 **入口点**。**Main** 方法说明当执行时 类将做什么动作。

- 下一行 /*...*/ 将会被编译器忽略，且它会在程序中添加额外的 **注释**。

- Main 方法通过语句

   

  Console.WriteLine("Hello World"); 

  指定了它的行为。

  *WriteLine* 是一个定义在 *System* 命名空间中的 *Console* 类的一个方法。该语句会在屏幕上显示消息 "Hello World"。

- 最后一行 **Console.ReadKey();** 是针对 VS.NET 用户的。这使得程序会等待一个按键的动作，防止程序从 Visual Studio .NET 启动时屏幕会快速运行并关闭。

### C#基本语法

**注意:**

- C#大小写敏感的。
- 所有的语句和表达式必须以分号`;`结尾。
- 与Java不同的是，文件名可以不同于类的名称。
- 程序的执行从 Main 方法开始

### 关键字

官网：https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2012/x53a06bb(v=vs.110)



关键字是 C# 编译器预定义的保留字。这些关键字不能用作标识符，但是，如果您想使用这些关键字作为标识符，可以在关键字前面加上 @ 字符作为前缀。

在 C# 中，有些关键字在代码的上下文中有特殊的意义，如 get 和 set，这些被称为上下文关键字（contextual keywords）。

下表列出了 C# 中的保留关键字（Reserved Keywords）和上下文关键字（Contextual Keywords）：

| **保留关键字**   |           |           |            |                        |                       |                |
| ---------------- | --------- | --------- | ---------- | ---------------------- | --------------------- | -------------- |
| abstract         | as        | base      | bool       | break                  | byte                  | case           |
| catch            | char      | checked   | class      | const                  | continue              | decimal        |
| default          | delegate  | do        | double     | else                   | enum                  | event          |
| explicit         | extern    | false     | finally    | fixed                  | float                 | for            |
| foreach          | goto      | if        | implicit   | in                     | in (generic modifier) | int            |
| interface        | internal  | is        | lock       | long                   | namespace             | new            |
| null             | object    | operator  | out        | out (generic modifier) | override              | params         |
| private          | protected | public    | readonly   | ref                    | return                | sbyte          |
| sealed           | short     | sizeof    | stackalloc | static                 | string                | struct         |
| switch           | this      | throw     | true       | try                    | typeof                | uint           |
| ulong            | unchecked | unsafe    | ushort     | using                  | virtual               | void           |
| volatile         | while     |           |            |                        |                       |                |
| **上下文关键字** |           |           |            |                        |                       |                |
| add              | alias     | ascending | descending | dynamic                | from                  | get            |
| global           | group     | into      | join       | let                    | orderby               | partial (type) |
| partial (method) | remove    | select    | set        |                        |                       |                |



void关键字

用作方法的返回类型，指定不返回值。

const关键字

指定字段或局部变量的值是常数，不能被修改。

#### as

转换操作符，若转换失败返回null。

C# 中的 'as' 关键字
      C# 中的 as 关键字用于安全类型转换。它尝试将一个对象转换为指定的类型，如果转换成功，则返回新类型的对象。如果转换失败，则返回 null 而不是抛出异常。

语法：
TargetType variableName = objectToCast as TargetType;
为什么使用 'as'？
      使用 as 进行转换的主要原因是其安全性。传统的类型转换在转换失败时可能导致异常，而 as 通过返回 null 优雅地处理这些情况。这在预期转换可能失败且可以通过编程方式处理的情况下特别有用。

何时使用 'as' 与直接转换
使用 as 时： 当你不确定转换是否会成功，并准备处理 null 结果时。
使用直接转换时： 当你确定对象的类型，并且失败的转换应该导致异常时。
示例：处理用户界面控件
      假设你正在开发一个 Windows Forms 应用程序，你有一个包含多种不同类型控件（例如 Button、TextBox、Label 等）的窗体。你想要编写一个方法，该方法遍历这些控件，并且只对 TextBox 类型的控件执行某些操作，比如清除它们的文本。

      在这个例子中，我们可以使用 as 关键字来安全地尝试将每个控件转换为 TextBox 类型，并检查转换是否成功。

代码示例：
foreach (Control control in this.Controls)
{
    TextBox textBox = control as TextBox;
    if (textBox != null)
    {
        // 只有当 control 是 TextBox 时，下面的代码才会执行
        textBox.Clear(); // 清除文本框中的文本
    }
}
      在这个例子中：

遍历窗体上的所有控件。
对于每个控件，使用 as 将其尝试转换为 TextBox 类型。
如果转换成功（即 textBox 不为 null），则执行特定于 TextBox 的操作，如清除文本。
      这种方法的优势在于它的安全性和简洁性。通过使用 as 关键字，我们避免了在控件不是 TextBox 类型时抛出异常的风险，并且可以优雅地处理不同类型的控件。这在处理具有多种类型子控件的复杂用户界面时特别有用。

#### Partial

用于将一个类、结构或接口的定义分为多个部分，这些部分可以在同一个命名空间中的多个文件中进行编写。这种分割使得可以将一个大型的实体定义分布在多个文件中，以便更好地组织和管理代码。

#### 访问修饰符关键字

- public：所有对象都可以访问；
- private：对象本身在对象内部可以访问；
- protected：只有该类对象及其子类对象可以访问
- internal：同一个程序集的对象可以访问；
- protected internal：访问限于当前程序集或派生自包含类的类型。

类的默认访问标识符是 **internal**，成员的默认访问标识符是 **private**。

#### internal

访问修饰符，允许在同一程序集的文件中内部类型和成员可以访问。同一个程序集表示同一个dll程序集或同一个exe程序集。在vs中一个项目会生成一个dll文件，因此这个dll或这个项目也就是一个程序集。比如在另一个程序中引用了common.dll，调用internal修饰的类会出错。可以在被引用的dll中使用[assembly: InternalsVisibleTo("Assembly2")]，允许Assembly2.dll使用

#### is

在C#中，`is`关键字是一个类型检查操作符，用于确定对象是否与给定类型兼容。它返回一个布尔值：如果对象兼容，则为`true`；如果不兼容或`null`，则为`false`。

下面是`is`关键字的一个简单示例：

```
class Class1 {}
class Class2 {}
class Class3 : Class2 { }

class IsTest
{
    static void Test(object o)
    {
        Class1 a;
        Class2 b;

        if (o is Class1)
        {
            Console.WriteLine("o is Class1");
            a = (Class1)o;
            // Do something with "a."
        }
        else if (o is Class2)
        {
            Console.WriteLine("o is Class2");
            b = (Class2)o;
            // Do something with "b."
        }

        else
        {
            Console.WriteLine("o is neither Class1 nor Class2.");
        }
    }
    static void Main()
    {
        Class1 c1 = new Class1();
        Class2 c2 = new Class2();
        Class3 c3 = new Class3();
        Test(c1);
        Test(c2);
        Test(c3);
        Test("a string");
    }
}
/*
Output:
o is Class1
o is Class2
o is Class2
o is neither Class1 nor Class2.
*/
```

protected关键字

访问修饰符，允许在其所在类中可由派生类访问。

try关键字

异常处理代码块的组成部分，包括可能会抛出异常的代码。

catch关键字

定义一个代码块，在特定类型异常抛出时，执行块内代码。

base关键字

用于访问被派生类或构造中的同名成员隐藏的基类成员。

abstract关键字

标识一个可以扩展但不能被实体化的、必须被实现的类或方法。

delegate关键字

指定一个声明为一种委托类型，委托把方法封装为可调用实体，能在委托实体中调用。

event关键字

声明一个全新的事件。允许一个类或对象提供通知的成员，必须是委托类型。

#### checked、unchecked

确保编译器运行时，检查整数类型操作或转换时出现的溢出。溢出后截断

unchecked关键字

禁止溢出检查。

enum关键字

枚举类型，特殊的值类型。

goto关键字

跳转语句，将程序执行重定向到一个标签语句。

foreach关键字

遍历。

namespace关键字

定义一个逻辑组的类型和命名空间。

ref关键字

标识一个参数值可能会受影响的参数。

struct关键字

可以声明值类型。

throw关键字

抛出异常。

#### typeof关键字

操作符，返回传入参数的类型。

System.Type type = typeof(int);

virtual关键字

标识可被覆载的方法。

#### using关键字

用于命名空间时，允许访问该命名空间中的类型而无需指定其全名。用于定义finalization操作的范围。

可以给命名空间取别名

using sys = 命名空间名；

static关键字

声明静态变量或静态函数。

extern关键字

声明在外部实现的方法。

object关键字

所有类型都是直接或间接从Object继承的，可以将任何类型的值赋给object类型的变量。

#### volatile

标识一个可被操作系统、某些硬件设备或并发线程修改的attribute。

`volatile` 关键字指示一个字段可以由多个同时执行的线程修改。 对字段的读取和写入保证是原子的，和java中效果相同。

#### readonly

可以在字段上使用的修饰符。当字段声明包括 readonly 修饰符时，该声明引入的字段赋值只能作为声明的一部分出现，或者出现在同一类的构造函数中。

标识一个变量的值在只可以在声明或者构造函数中，之后不可以改变。

#### params

声明一个参数数组。

```
public class MyClass
{
    public static void UseParams(params int[] list)
    {
        for (int i = 0; i < list.Length; i++)
        {
            Console.Write(list[i] + " ");
        }
        Console.WriteLine();
    }

    public static void UseParams2(params object[] list)
    {
        for (int i = 0; i < list.Length; i++)
        {
            Console.Write(list[i] + " ");
        }
        Console.WriteLine();
    }

    static void Main()
    {
        // You can send a comma-separated list of arguments of the 
        // specified type.
        UseParams(1, 2, 3, 4);
        UseParams2(1, 'a', "test");

        // A params parameter accepts zero or more arguments.
        // The following calling statement displays only a blank line.
        UseParams2();

        // An array argument can be passed, as long as the array
        // type matches the parameter type of the method being called.
        int[] myIntArray = { 5, 6, 7, 8, 9 };
        UseParams(myIntArray);

        object[] myObjArray = { 2, 'b', "test", "again" };
        UseParams2(myObjArray);

        // The following call causes a compiler error because the object
        // array cannot be converted into an integer array.
        //UseParams(myObjArray);

        // The following call does not cause an error, but the entire 
        // integer array becomes the first element of the params array.
        UseParams2(myIntArray);
    }
}
/*
Output:
    1 2 3 4
    1 a test

    5 6 7 8 9
    2 b test again
    System.Int32[]
*/
```

interface关键字

将一个声明指定为接口类型，即实现类或构造必须遵循的合同。

#### ref, in, out

in 关键字用于将参数按只读方式传递给方法。被声明为 in 的参数在方法内部不能修改，只能去读取。
in 关键字适用于传递大型结构体或引用类型的情况，以避免不必要的拷贝开销，并确保方法内部不会修改传递的参数值。
in 关键字在方法调用时，可以传递变量、常量或表达式。

```
#### void ProcessData(in int value)
{
    // 无法修改 value 的值
    // ...
}

int number = 10;
ProcessData(in number);
```

out 关键字：
特征
out 关键字用于将方法的输出参数传递给调用方。被声明为 out 的参数在方法内部必须被赋值，且在方法返回前必须赋值。
out 关键字适用于需要返回多个值的情况，方法可以通过 out 参数将多个值传递给调用方。
out 关键字在方法调用时，必须传递变量，而不能传递常量或表达式。

```
void GetValues(out int x, out int y)
{
    x = 10;
    y = 20;
}

int a, b;
GetValues(out a, out b);
```

ref 关键字：
特征
ref 关键字用于将参数按引用方式传递给方法。被声明为 ref 的参数在方法内部可以修改，并且方法内外使用同一份数据。
ref 关键字适用于需要在方法内部修改传递的参数值，并希望在方法调用后对原始变量产生影响的情况。
ref 关键字在方法调用时，必须传递变量，而不能传递常量或表达式。

```
void Swap(ref int a, ref int b)
{
    int temp = a;
    a = b;
    b = temp;
}

int x = 10, y = 20;
Swap(ref x, ref y);
```

需要注意的是，in、out 和 ref 关键字在使用时需要遵循一定的规则，并且在方法签名的声明和调用时需要保持一致。而且，在使用 out 和 ref 关键字时，需要确保在方法内部为这些参数赋值，否则会导致编译错误。

in 关键字用于向函数传递值；
out 关键字用于从函数接收值，通常用于接收多个返回值（返回值只有一个时，直接用函数返回值就行）；
ref 关键字用于通过函数操作变量， 也可以用于向函数传递值或从函数接收值；
ref 与 out 相同之处在于：传递的都是地址/引用。
ref 与 out 不同之处在于：编译器对两种关键字修饰的变量进行的安全性检测不同。

-  1）.ref 型传递变量前，变量必须初始化，否则编译器会报错, 而 out 型则不需要初始化
-  2）.ref 型传递变量，数值可以传入方法中，而 out 型无法将数据传入方法中。换而言之，ref 型有进有出，out 型只出不进。
- out 在被调用的方法中必须赋值



C#中数据类型有两种：

- 值类型，int, struct等，如下方的GraphStruct。
- 引用类型，所有的class都是引用类型，如下方的Graph。

```


public class Graph
    {
        public int area { get; set; }
        public int perimeter { get; set; }

        public Graph(int area,int perimeter)
        {
            this.area = area;  
            this.perimeter = perimeter;
        }
    }

    public struct GraphStruct
    {
        public int area { get; set; }
        public int perimeter { get; set; }
        public GraphStruct(int area, int perimeter)
        {
            this.area=area;
            this.perimeter=perimeter;
        }
    }
```

out：标识一个参数值会受影响的参数，但在传入方法时，该参数无需先初始化。

#### sizeof

操作符，以byte为单位返回一个值类型的长度。

stackalloc关键字

返回在堆上分配的一个内存块的指针。

#### sealed

sealed：密封

防止类型被派生，防止方法和property被覆载。在声明中使用可以防止该类被其他类继承。

unsafe关键字

标注包含指针操作的代码块、方法或类。

override关键字

在派生类中声明对虚方法的重载。

implicit关键字

定义一个用户定义的转换操作符。通常用来将预定义类型转换为用户定义类型或反向操作。隐式转换操作符必须在转换时使用。

#### lock

lock 关键字可以用来实现线程同步，确保在多线程环境中只有一个线程可以访问被锁定的资源。同java的synchronized

lock (object) { // 需要同步的代码 }



#### explicit、implicit、operator

operator用来**重载内置运算符**，或提供类或结构声明中的**用户自定义转换**

https://blog.csdn.net/yuhai738639/article/details/75347606

```
public static Box operator+ (Box b, Box c)
{
   Box box = new Box();
   box.length = b.length + c.length;
   box.breadth = b.breadth + c.breadth;
   box.height = b.height + c.height;
   return box;
}
```



explicit:明确的

explicit是用于用户自定义转换操作符的关键字。通常用来将内建类型转换为用户定义类型或反向操作。必须在转换时调用**显式转换操作符**。

implicit和explicit区别是，explicit是调用隐式转换操作符

Animal animal2 = (Animal)"狗";            //”字符串“到Animal的” 显式转换 “
Animal animal3 = "狼";                          //”字符串“到Animal的”隐式转换 “

语法： public static 关键字 operator 要转换的目标类型(被转换的类型)   {    }

下面是一个使用 `explicit` 关键字的示例，其中定义了一个 `Temperature` 类和一个 `Celsius` 类，并在这两个类之间提供了一个显式转换运算符：

public static explicit operator Celsius(Temperature temp)
    {
        return new Celsius(temp.Degrees);
    }

```
public class Temperature
{
    public double Degrees { get; }
 
    public Temperature(double degrees)
    {
        Degrees = degrees;
    }
 
    public static explicit operator Celsius(Temperature temp)
    {
        return new Celsius(temp.Degrees);
    }
}
 
public class Celsius
{
    public double Degrees { get; }
 
    public Celsius(double degrees)
    {
        Degrees = degrees;
    }
}
 
class Program
{
    static void Main(string[] args)
    {
        Temperature temp = new Temperature(100);
        Celsius celsius = (Celsius)temp; // 显式转换
    }
} 
```

#### unsafe、fixed

unsafe
unsafe关键字用于声明不安全的代码块。在C#中，默认情况下，代码是安全的，这意味着它遵循.NET的安全规则，包括对内存的访问控制。使用unsafe关键字可以告诉编译器，你了解并信任这段代码，即使它可能违反安全规则。

使用unsafe关键字需要满足一些条件：

你的项目必须被标记为允许不安全代码（通过在项目的属性中设置Allow Unsafe Code）。
你的代码必须在unsafe代码块中。
你必须使用fixed关键字来固定内存块。
fixed
fixed 关键字在 C# 中主要用于固定内存地址，通常与不安全代码（unsafe）一起使用。当你在不安全的代码中直接访问内存时，使用 fixed 关键字可以确保内存地址在程序运行期间保持不变。

使用 fixed 关键字的主要原因是：在垃圾回收过程中，垃圾回收器可能会移动内存中的对象。如果一个指针指向一个对象，而该对象在垃圾回收过程中被移动，那么该指针就会变得无效。通过使用 fixed 关键字，你可以告诉垃圾回收器不要移动这个对象，从而确保指针始终指向有效的内存地址。

示例：

```
unsafe class Example  
{  
    int[] array = new int[10];  
    fixed int* ptr = stackalloc int[] { 1, 2, 3 };  
  
    void Method()  
    {  
        int* p = ptr; // 这里的p指向一个固定的内存地址  
        for (int i = 0; i < array.Length; i++)  
        {  
            *(p + i) = array[i]; // 将数组的值赋给固定的内存地址  
        }  
    }  
}
```

在这个例子中，我们创建了一个固定大小的数组 ptr，并在方法 Method 中使用它来修改另一个数组 array 的值。因为 ptr 是用 fixed 关键字声明的，所以它指向的内存地址在 Method 执行期间是固定的，不会发生位移

#### stackalloc 

staclalloc关键字将在栈上显式分配一块内存, 因为是在栈内分配，因此生命周期和其他局部变量受限于方法执行期。stackalloc 关键字用于不安全的代码上下文中。



```csharp
            unsafe
            {
                int* a = stackalloc int[10];
                for (int i = 0; i < 10; i++)
                {
                    Console.WriteLine(a[i]);
                }
            }
```



#### virtual 、override、new

- override 方法提供从基类继承的成员的新实现。
- 重写的基方法必须与 override 方法具有相同的签名。
- 不能重写非虚方法或静态方法。重写的基方法必须是 virtual、abstract 或 override 的。
- override 声明不能更改 virtual 方法的可访问性。 override 方法和 virtual 方法必须具有相同的访问级别修饰符。
- 您不能使用 new、static 或 virtual 修饰符来修改 override 方法。
- 如果派生类中的方法前面没有 [new](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/new-modifier) 或 [override](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/override) 关键字，则编译器将发出警告，该方法将如同存在 `new` 关键字一样执行操作。
- 如果派生类中的方法前面带有 `new` 关键字，则该方法被定义为独立于基类中的方法。
- 如果派生类中的方法前面带有 `override` 关键字，则派生类的对象将调用该方法，而不是调用基类方法。
- 若要将 `override` 关键字应用于派生类中的方法，必须以[虚拟](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/virtual)形式定义基类方法。
- 可以从派生类中使用 `base` 关键字调用基类方法。
- `override`、`virtual` 和 `new` 关键字还可以用于属性、索引器和事件中。

### 变量

- C# 中提供的基本类型大致分为以下几类：

  | 类型       | 举例                   |
  | ---------- | ---------------------- |
  | 整数类型   | byte、short、int、long |
  | 浮点型     | float、double          |
  | 十进制类型 | decimal                |
  | 布尔类型   | bool                   |
  | 字符类型   | string、char           |
  | 空类型     | null                   |

### 表达式

有用的：





| **类别**       | **表达式**       | **说明**                                          |
| -------------- | ---------------- | ------------------------------------------------- |
| 基本           | `x.m`            | 成员访问                                          |
|                | `x(...)`         | 方法和委托调用                                    |
|                | `x[...]`         | 数组和索引器访问                                  |
|                | `newT(...)`      | 对象和委托创建                                    |
|                | `newT(...){...}` | 使用初始值设定项创建对象                          |
|                | `new{...}`       | 匿名对象初始值设定项                              |
|                | `newT[...]`      | 数组创建                                          |
| 一元           | `+x`             | 恒等                                              |
|                | `-x`             | 求相反数                                          |
|                | `!x`             | 逻辑求反                                          |
|                | `~x`             | 按位求反                                          |
|                | `++x`            | 前增量                                            |
|                | `--x`            | 前减量                                            |
|                | `x++`            | 后增量                                            |
|                | `x--`            | 后减量                                            |
|                | `(T)x`           | 将x显示转换为类型T                                |
| 二元           | `x * y`          | 乘法                                              |
|                | `x / y`          | 除法                                              |
|                | `x % y`          | 取余                                              |
|                | `x + y`          | 加法，字符串串联                                  |
|                | `x - y`          | 减法                                              |
|                | `x << y`         | 位左移                                            |
|                | `x >> y`         | 位右移                                            |
|                | `x < y`          | 小于                                              |
|                | `x > y`          | 大于                                              |
|                | `x <= y`         | 小于或等于                                        |
|                | `x >= y`         | 大于或等于                                        |
|                | `x  is T`        | 如果 x 为 T ，返回`true`，否则`false`             |
|                | `x  as T`        | 返回转换为类型 T 的 x ,如果 x 不是 T 则返回`null` |
|                | `x == y`         | 等于                                              |
|                | `x != y`         | 不等于                                            |
|                | `x & y`          | 整形按位与 ,布尔逻辑AND                           |
|                | `x               | y`                                                |
|                | `x && y`         | 且，当 x 为`true`时，才对 y 求值                  |
|                | `x               |                                                   |
|                | `x ?? y`         | 如果 x 为`null`，则计算结果为 y，否则为 x         |
| 三元           | `x ? y : z`      | 如果 x 为`true`,对 y 求值，x 为`false`，对 z 求值 |
| 赋值或匿名函数 | `x = y`          | 赋值                                              |
|                | `x = x + y`      | 复合赋值                                          |
|                | `(T x) => y`     | 匿名函数（lambda表达式）                          |

## 文件处理

https://www.runoob.com/csharp/csharp-file-io.html

一个 **文件** 是一个存储在磁盘中带有指定名称和目录路径的数据集合。当打开文件进行读写时，它变成一个 **流**。

从根本上说，流是通过通信路径传递的字节序列。有两个主要的流：**输入流** 和 **输出流**。**输入流**用于从文件读取数据（读操作），**输出流**用于向文件写入数据（写操作）。

System.IO 命名空间中常用的非抽象类：

| I/O 类         | 描述                               |
| :------------- | :--------------------------------- |
| BinaryReader   | 从二进制流读取原始数据。           |
| BinaryWriter   | 以二进制格式写入原始数据。         |
| BufferedStream | 字节流的临时存储。                 |
| Directory      | 有助于操作目录结构。               |
| DirectoryInfo  | 用于对目录执行操作。               |
| DriveInfo      | 提供驱动器的信息。                 |
| File           | 有助于处理文件。                   |
| FileInfo       | 用于对文件执行操作。               |
| FileStream     | 用于文件中任何位置的读写。         |
| MemoryStream   | 用于随机访问存储在内存中的数据流。 |
| Path           | 对路径信息执行操作。               |
| StreamReader   | 用于从字节流中读取字符。           |
| StreamWriter   | 用于向一个流中写入字符。           |
| StringReader   | 用于读取字符串缓冲区。             |
| StringWriter   | 用于写入字符串缓冲区。             |

### FileStream 类

```
FileStream F = new FileStream("sample.txt", FileMode.Open, FileAccess.Read, FileShare.Read);
```

| 参数       | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| FileMode   | **FileMode** 枚举定义了各种打开文件的方法。FileMode 枚举的成员有：**Append**：打开一个已有的文件，并将光标放置在文件的末尾。如果文件不存在，则创建文件。**Create**：创建一个新的文件。如果文件已存在，则删除旧文件，然后创建新文件。**CreateNew**：指定操作系统应创建一个新的文件。如果文件已存在，则抛出异常。**Open**：打开一个已有的文件。如果文件不存在，则抛出异常。**OpenOrCreate**：指定操作系统应打开一个已有的文件。如果文件不存在，则用指定的名称创建一个新的文件打开。**Truncate**：打开一个已有的文件，文件一旦打开，就将被截断为零字节大小。然后我们可以向文件写入全新的数据，但是保留文件的初始创建日期。如果文件不存在，则抛出异常。 |
| FileAccess | **FileAccess** 枚举的成员有：**Read**、**ReadWrite** 和 **Write**。 |
| FileShare  | **FileShare** 枚举的成员有：**Inheritable**：允许文件句柄可由子进程继承。Win32 不直接支持此功能。**None**：谢绝共享当前文件。文件关闭前，打开该文件的任何请求（由此进程或另一进程发出的请求）都将失败。**Read**：允许随后打开文件读取。如果未指定此标志，则文件关闭前，任何打开该文件以进行读取的请求（由此进程或另一进程发出的请求）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。**ReadWrite**：允许随后打开文件读取或写入。如果未指定此标志，则文件关闭前，任何打开该文件以进行读取或写入的请求（由此进程或另一进程发出）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。**Write**：允许随后打开文件写入。如果未指定此标志，则文件关闭前，任何打开该文件以进行写入的请求（由此进程或另一进过程发出的请求）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。**Delete**：允许随后删除文件。 |

```
using System;
using System.IO;

namespace FileIOApplication
{
    class Program
    {
        static void Main(string[] args)
        {
            FileStream F = new FileStream("test.dat", 
            FileMode.OpenOrCreate, FileAccess.ReadWrite);

            for (int i = 1; i <= 20; i++)
            {
                F.WriteByte((byte)i);
            }

            F.Position = 0;

            for (int i = 0; i <= 20; i++)
            {
                Console.Write(F.ReadByte() + " ");
            }
            F.Close();
            Console.ReadKey();
        }
    }
}
```



### **StreamReader** 和 *StreamWriter*

**StreamReader** 类继承自抽象基类 TextReader，表示阅读器读取一系列字符

| 序号 | 方法 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **public override void Close()** 关闭 StreamReader 对象和基础流，并释放任何与读者相关的系统资源。 |
| 2    | **public override int Peek()** 返回下一个可用的字符，但不使用它。 |
| 3    | **public override int Read()** 从输入流中读取下一个字符，并把字符位置往前移一个字符。 |



```
using System;
using System.IO;

namespace FileApplication
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                // 创建一个 StreamReader 的实例来读取文件 
                // using 语句也能关闭 StreamReader
                using (StreamReader sr = new StreamReader("c:/jamaica.txt", Encoding.UTF8))
                {
                    string line;
                   
                    // 从文件读取并显示行，直到文件的末尾 
                    while ((line = sr.ReadLine()) != null)
                    {
                        Console.WriteLine(line);
                    }
                }
            }
            catch (Exception e)
            {
                // 向用户显示出错消息
                Console.WriteLine("The file could not be read:");
                Console.WriteLine(e.Message);
            }
            Console.ReadKey();
        }
    }
}

```

StreamWriter

**StreamWriter** 类继承自抽象类 TextWriter，表示编写器写入一系列字符。下表列出了 **StreamWriter** 类中一些常用的**方法**：

| 序号 | 方法 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **public override void Close()** 关闭当前的 StreamWriter 对象和基础流。 |
| 2    | **public override void Flush()** 清理当前编写器的所有缓冲区，使得所有缓冲数据写入基础流。 |
| 3    | **public virtual void Write(bool value)** 把一个布尔值的文本表示形式写入到文本字符串或流。（继承自 TextWriter。） |
| 4    | **public override void Write( char value )** 把一个字符写入到流。 |
| 5    | **public virtual void Write( decimal value )** 把一个十进制值的文本表示形式写入到文本字符串或流。 |
| 6    | **public virtual void Write( double value )** 把一个 8 字节浮点值的文本表示形式写入到文本字符串或流。 |
| 7    | **public virtual void Write( int value )** 把一个 4 字节有符号整数的文本表示形式写入到文本字符串或流。 |
| 8    | **public override void Write( string value )** 把一个字符串写入到流。 |
| 9    | **public virtual void WriteLine()** 把行结束符写入到文本字符串或流。 |

### **BinaryReader** 和 **BinaryWriter**

**BinaryReader** 类用于从文件读取二进制数据。一个 **BinaryReader** 对象通过向它的构造函数传递 **FileStream** 对象而被创建。

下表列出了 **BinaryReader** 类中一些常用的**方法**：

| 序号 | 方法 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **public override void Close()** 关闭 BinaryReader 对象和基础流。 |
| 2    | **public virtual int Read()** 从基础流中读取字符，并把流的当前位置往前移。 |
| 3    | **public virtual bool ReadBoolean()** 从当前流中读取一个布尔值，并把流的当前位置往前移一个字节。 |
| 4    | **public virtual byte ReadByte()** 从当前流中读取下一个字节，并把流的当前位置往前移一个字节。 |
| 5    | **public virtual byte[] ReadBytes( int count )** 从当前流中读取指定数目的字节到一个字节数组中，并把流的当前位置往前移指定数目的字节。 |
| 6    | **public virtual char ReadChar()** 从当前流中读取下一个字节，并把流的当前位置按照所使用的编码和从流中读取的指定的字符往前移。 |
| 7    | **public virtual char[] ReadChars( int count )** 从当前流中读取指定数目的字节，在一个字符数组中返回数组，并把流的当前位置按照所使用的编码和从流中读取的指定的字符往前移。 |
| 8    | **public virtual double ReadDouble()** 从当前流中读取一个 8 字节浮点值，并把流的当前位置往前移八个字节。 |
| 9    | **public virtual int ReadInt32()** 从当前流中读取一个 4 字节有符号整数，并把流的当前位置往前移四个字节。 |
| 10   | **public virtual string ReadString()** 从当前流中读取一个字符串。字符串以长度作为前缀，同时编码为一个七位的整数。 |



BinaryWriter 类

**BinaryWriter** 类用于向文件写入二进制数据。一个 **BinaryWriter** 对象通过向它的构造函数传递 **FileStream** 对象而被创建。

下表列出了 **BinaryWriter** 类中一些常用的**方法**：

| 序号 | 方法 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **public override void Close()** 关闭 BinaryWriter 对象和基础流。 |
| 2    | **public virtual void Flush()** 清理当前编写器的所有缓冲区，使得所有缓冲数据写入基础设备。 |
| 3    | **public virtual long Seek( int offset, SeekOrigin origin )** 设置当前流内的位置。 |
| 4    | **public virtual void Write( bool value )** 把一个单字节的布尔值写入到当前流中，0 表示 false，1 表示 true。 |
| 5    | **public virtual void Write( byte value )** 把一个无符号字节写入到当前流中，并把流的位置往前移一个字节。 |
| 6    | **public virtual void Write( byte[] buffer )** 把一个字节数组写入到基础流中。 |
| 7    | **public virtual void Write( char ch )** 把一个 Unicode 字符写入到当前流中，并把流的当前位置按照所使用的编码和要写入到流中的指定的字符往前移。 |
| 8    | **public virtual void Write( char[] chars )** 把一个字符数组写入到当前流中，并把流的当前位置按照所使用的编码和要写入到流中的指定的字符往前移。 |
| 9    | **public virtual void Write( double value )** 把一个 8 字节浮点值写入到当前流中，并把流位置往前移八个字节。 |
| 10   | **public virtual void Write( int value )** 把一个 4 字节有符号整数写入到当前流中，并把流位置往前移四个字节。 |
| 11   | **public virtual void Write( string value )** 把一个以长度为前缀的字符串写入到 BinaryWriter 的当前编码的流中，并把流的当前位置按照所使用的编码和要写入到流中的指定的字符往前移。 |



```
using System;
using System.IO;

namespace BinaryFileApplication
{
    class Program
    {
        static void Main(string[] args)
        {
            BinaryWriter bw;
            BinaryReader br;
            int i = 25;
            double d = 3.14157;
            bool b = true;
            string s = "I am happy";
            // 创建文件
            try
            {
                bw = new BinaryWriter(new FileStream("mydata",
                                FileMode.Create));
            }
            catch (IOException e)
            {
                Console.WriteLine(e.Message + "\n Cannot create file.");
                return;
            }
            // 写入文件
            try
            {
                bw.Write(i);
                bw.Write(d);
                bw.Write(b);
                bw.Write(s);
            }
            catch (IOException e)
            {
                Console.WriteLine(e.Message + "\n Cannot write to file.");
                return;
            }

            bw.Close();
            // 读取文件
            try
            {
                br = new BinaryReader(new FileStream("mydata",
                                FileMode.Open));
            }
            catch (IOException e)
            {
                Console.WriteLine(e.Message + "\n Cannot open file.");
                return;
            }
            try
            {
                i = br.ReadInt32();
                Console.WriteLine("Integer data: {0}", i);
                d = br.ReadDouble();
                Console.WriteLine("Double data: {0}", d);
                b = br.ReadBoolean();
                Console.WriteLine("Boolean data: {0}", b);
                s = br.ReadString();
                Console.WriteLine("String data: {0}", s);
            }
            catch (IOException e)
            {
                Console.WriteLine(e.Message + "\n Cannot read from file.");
                return;
            }
            br.Close();
            Console.ReadKey();
        }
    }
}
```

### 操作目录和文件

**DirectoryInfo** 类和 **FileInfo** 类。

## DirectoryInfo 类

**DirectoryInfo** 类派生自 **FileSystemInfo** 类。它提供了各种用于创建、移动、浏览目录和子目录的方法。该类不能被继承。

下表列出了 **DirectoryInfo** 类中一些常用的**属性**：

| 序号 | 属性 & 描述                                             |
| :--- | :------------------------------------------------------ |
| 1    | **Attributes** 获取当前文件或目录的属性。               |
| 2    | **CreationTime** 获取当前文件或目录的创建时间。         |
| 3    | **Exists** 获取一个表示目录是否存在的布尔值。           |
| 4    | **Extension** 获取表示文件存在的字符串。                |
| 5    | **FullName** 获取目录或文件的完整路径。                 |
| 6    | **LastAccessTime** 获取当前文件或目录最后被访问的时间。 |
| 7    | **Name** 获取该 DirectoryInfo 实例的名称。              |

下表列出了 **DirectoryInfo** 类中一些常用的**方法**：

| 序号 | 方法 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **public void Create()** 创建一个目录。                      |
| 2    | **public DirectoryInfo CreateSubdirectory( string path )** 在指定的路径上创建子目录。指定的路径可以是相对于 DirectoryInfo 类的实例的路径。 |
| 3    | **public override void Delete()** 如果为空的，则删除该 DirectoryInfo。 |
| 4    | **public DirectoryInfo[] GetDirectories()** 返回当前目录的子目录。 |
| 5    | **public FileInfo[] GetFiles()** 从当前目录返回文件列表。    |

## FileInfo 类

**FileInfo** 类派生自 **FileSystemInfo** 类。它提供了用于创建、复制、删除、移动、打开文件的属性和方法，且有助于 FileStream 对象的创建。该类不能被继承。

下表列出了 **FileInfo** 类中一些常用的**属性**：

| 序号 | 属性 & 描述                                       |
| :--- | :------------------------------------------------ |
| 1    | **Attributes** 获取当前文件的属性。               |
| 2    | **CreationTime** 获取当前文件的创建时间。         |
| 3    | **Directory** 获取文件所属目录的一个实例。        |
| 4    | **Exists** 获取一个表示文件是否存在的布尔值。     |
| 5    | **Extension** 获取表示文件存在的字符串。          |
| 6    | **FullName** 获取文件的完整路径。                 |
| 7    | **LastAccessTime** 获取当前文件最后被访问的时间。 |
| 8    | **LastWriteTime** 获取文件最后被写入的时间。      |
| 9    | **Length** 获取当前文件的大小，以字节为单位。     |
| 10   | **Name** 获取文件的名称。                         |

下表列出了 **FileInfo** 类中一些常用的**方法**：

| 序号 | 方法 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **public StreamWriter AppendText()** 创建一个 StreamWriter，追加文本到由 FileInfo 的实例表示的文件中。 |
| 2    | **public FileStream Create()** 创建一个文件。                |
| 3    | **public override void Delete()** 永久删除一个文件。         |
| 4    | **public void MoveTo( string destFileName )** 移动一个指定的文件到一个新的位置，提供选项来指定新的文件名。 |
| 5    | **public FileStream Open( FileMode mode )** 以指定的模式打开一个文件。 |
| 6    | **public FileStream Open( FileMode mode, FileAccess access )** 以指定的模式，使用 read、write 或 read/write 访问，来打开一个文件。 |
| 7    | **public FileStream Open( FileMode mode, FileAccess access, FileShare share )** 以指定的模式，使用 read、write 或 read/write 访问，以及指定的分享选项，来打开一个文件。 |
| 8    | **public FileStream OpenRead()** 创建一个只读的 FileStream。 |
| 9    | **public FileStream OpenWrite()** 创建一个只写的 FileStream。 |

## C# 可空类型（Nullable）

**?** 单问号用于对 **int、double、bool**、struct 等无法直接赋值为 null 的数据类型进行 null 的赋值，意思是这个数据类型是 Nullable 类型的。

```
int? i = 3;
```

等同于：

```
Nullable<int> i = new Nullable<int>(3);
int i; //默认值0
int? ii; //默认值null
```

**??** 双问号用于判断一个变量在为 null 的时候返回一个指定的值。

**double** num3;
 num3 = num1 ?? 5.34;    *// num1 如果为空值则返回 5.34*



## 命名空间（Namespace）

在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。

命名空间可以被嵌套，即您可以在一个命名空间内定义另一个命名空间

*using* 关键字

**using** 关键字表明程序使用的是给定命名空间中的名称。例如，我们在程序中使用 **System** 命名空间，其中定义了类 Console。我们可以只写：

```
Console.WriteLine ("Hello there");
```

我们可以写完全限定名称，如下：

```
System.Console.WriteLine("Hello there");
```

您也可以使用 **using** 命名空间指令，这样在使用的时候就不用在前面加上命名空间名称。该指令告诉编译器随后的代码使用了指定命名空间中的名称。

## C# 预处理器指令

预处理器指令指导编译器在实际编译开始之前对信息进行预处理。

所有的预处理器指令都是以 # 开始。且在一行上，只有空白字符可以出现在预处理器指令之前。预处理器指令不是语句，所以它们不以分号（;）结束。

C# 编译器没有一个单独的预处理器，但是，指令被处理时就像是有一个单独的预处理器一样。在 C# 中，预处理器指令用于在条件编译中起作用。与 C 和 C++ 不同的是，它们不是用来创建宏。一个预处理器指令必须是该行上的唯一指令。

## C# 预处理器指令列表

下表列出了 C# 中可用的预处理器指令：

| 预处理器指令 | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| #define      | 它用于定义一系列成为符号的字符。                             |
| #undef       | 它用于取消定义符号。                                         |
| #if          | 它用于测试符号是否为真。                                     |
| #else        | 它用于创建复合条件指令，与 #if 一起使用。                    |
| #elif        | 它用于创建复合条件指令。                                     |
| #endif       | 指定一个条件指令的结束。                                     |
| #line        | 它可以让您修改编译器的行数以及（可选地）输出错误和警告的文件名。 |
| #error       | 它允许从代码的指定位置生成一个错误。                         |
| #warning     | 它允许从代码的指定位置生成一级警告。                         |
| #region      | 它可以让您在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块。 |
| #endregion   | 它标识着 #region 块的结束。                                  |

```
#define PI 
using System;
namespace PreprocessorDAppl
{
   class Program
   {
      static void Main(string[] args)
      {
         #if (PI)
            Console.WriteLine("PI is defined");
         #else
            Console.WriteLine("PI is not defined");
         #endif
         Console.ReadKey();
      }
   }
}
```



# C#高级

## C# 特性（Attribute）

java的注解

**特性（Attribute）**是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。您可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。

特性（Attribute）用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net 框架提供了两种类型的特性：*预定义*特性和*自定义*特性。

### 预定义特性（Attribute）

.Net 框架提供了三种预定义特性：

- AttributeUsage
- Conditional
- Obsolete

#### AttributeUsage

预定义特性 **AttributeUsage** 描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。

规定该特性的语法如下：

```
[AttributeUsage(
   validon,
   AllowMultiple=allowmultiple,
   Inherited=inherited
)]
```

其中：

- 参数 validon 规定特性可被放置的语言元素。它是枚举器 *AttributeTargets* 的值的组合。默认值是 *AttributeTargets.All*。
- 参数 *allowmultiple*（可选的）为该特性的 *AllowMultiple* 属性（property）提供一个布尔值。如果为 true，则该特性是多用的。默认值是 false（单用的）。
- 参数 *inherited*（可选的）为该特性的 *Inherited* 属性（property）提供一个布尔值。如果为 true，则该特性可被派生类继承。默认值是 false（不被继承）。

例如：

```
[AttributeUsage(AttributeTargets.Class |
AttributeTargets.Constructor |
AttributeTargets.Field |
AttributeTargets.Method |
AttributeTargets.Property, 
AllowMultiple = true)]
```

#### Conditional

这个预定义特性标记了一个条件方法，其执行依赖于指定的预处理标识符。

它会引起方法调用的条件编译，取决于指定的值，比如 **Debug** 或 **Trace**。例如，当调试代码时显示变量的值。

规定该特性的语法如下：

```
[Conditional(
   conditionalSymbol
)]
```

例如：

```
[Conditional("DEBUG")]
```

#### Obsolete

这个预定义特性标记了不应被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。例如，当一个新方法被用在一个类中，但是您仍然想要保持类中的旧方法，您可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为 obsolete（过时的）。

规定该特性的语法如下：

```
[Obsolete(
   message
)]
[Obsolete(
   message,
   iserror
)]
```

其中：

- 参数 *message*，是一个字符串，描述项目为什么过时以及该替代使用什么。
- 参数 *iserror*，是一个布尔值。如果该值为 true，编译器应把该项目的使用当作一个错误。默认值是 false（编译器生成一个警告）。

## C# 反射（Reflection）

反射（Reflection）有下列用途：

- 它允许在运行时查看特性（attribute）信息。
- 它允许审查集合中的各种类型，以及实例化这些类型。
- 它允许延迟绑定的方法和属性（property）。
- 它允许在运行时创建新类型，然后使用这些类型执行一些任务。

### 查看元数据

使用反射（Reflection）可以查看特性（attribute）信息。

```
System.Reflection.MemberInfo info = typeof(MyClass);
```

```
using System;

[AttributeUsage(AttributeTargets.All)]
public class HelpAttribute : System.Attribute
{
   public readonly string Url;

   public string Topic  // Topic 是一个命名（named）参数
   {
      get
      {
         return topic;
      }
      set
      {

         topic = value;
      }
   }

   public HelpAttribute(string url)  // url 是一个定位（positional）参数
   {
      this.Url = url;
   }

   private string topic;
}
[HelpAttribute("Information on the class MyClass")]
class MyClass
{
}

namespace AttributeAppl
{
   class Program
   {
      static void Main(string[] args)
      {
         System.Reflection.MemberInfo info = typeof(MyClass);
         object[] attributes = info.GetCustomAttributes(true);
         for (int i = 0; i < attributes.Length; i++)
         {
            System.Console.WriteLine(attributes[i]);
         }
         Console.ReadKey();

      }
   }
}
```



例子2

```
using System;
using System.Reflection;
namespace BugFixApplication
{
   // 一个自定义特性 BugFix 被赋给类及其成员
   [AttributeUsage(AttributeTargets.Class |
   AttributeTargets.Constructor |
   AttributeTargets.Field |
   AttributeTargets.Method |
   AttributeTargets.Property,
   AllowMultiple = true)]

   public class DeBugInfo : System.Attribute
   {
      private int bugNo;
      private string developer;
      private string lastReview;
      public string message;

      public DeBugInfo(int bg, string dev, string d)
      {
         this.bugNo = bg;
         this.developer = dev;
         this.lastReview = d;
      }

      public int BugNo
      {
         get
         {
            return bugNo;
         }
      }
      public string Developer
      {
         get
         {
            return developer;
         }
      }
      public string LastReview
      {
         get
         {
            return lastReview;
         }
      }
      public string Message
      {
         get
         {
            return message;
         }
         set
         {
            message = value;
         }
      }
   }
   [DeBugInfo(45, "Zara Ali", "12/8/2012",
        Message = "Return type mismatch")]
   [DeBugInfo(49, "Nuha Ali", "10/10/2012",
        Message = "Unused variable")]
   class Rectangle
   {
      // 成员变量
      protected double length;
      protected double width;
      public Rectangle(double l, double w)
      {
         length = l;
         width = w;
      }
      [DeBugInfo(55, "Zara Ali", "19/10/2012",
           Message = "Return type mismatch")]
      public double GetArea()
      {
         return length * width;
      }
      [DeBugInfo(56, "Zara Ali", "19/10/2012")]
      public void Display()
      {
         Console.WriteLine("Length: {0}", length);
         Console.WriteLine("Width: {0}", width);
         Console.WriteLine("Area: {0}", GetArea());
      }
   }//end class Rectangle  
   
   class ExecuteRectangle
   {
      static void Main(string[] args)
      {
         Rectangle r = new Rectangle(4.5, 7.5);
         r.Display();
         Type type = typeof(Rectangle);
         // 遍历 Rectangle 类的特性
         foreach (Object attributes in type.GetCustomAttributes(false))
         {
            DeBugInfo dbi = (DeBugInfo)attributes;
            if (null != dbi)
            {
               Console.WriteLine("Bug no: {0}", dbi.BugNo);
               Console.WriteLine("Developer: {0}", dbi.Developer);
               Console.WriteLine("Last Reviewed: {0}",
                                        dbi.LastReview);
               Console.WriteLine("Remarks: {0}", dbi.Message);
            }
         }
         
         // 遍历方法特性
         foreach (MethodInfo m in type.GetMethods())
         {
            foreach (Attribute a in m.GetCustomAttributes(true))
            {
               DeBugInfo dbi = (DeBugInfo)a;
               if (null != dbi)
               {
                  Console.WriteLine("Bug no: {0}, for Method: {1}",
                                                dbi.BugNo, m.Name);
                  Console.WriteLine("Developer: {0}", dbi.Developer);
                  Console.WriteLine("Last Reviewed: {0}",
                                                dbi.LastReview);
                  Console.WriteLine("Remarks: {0}", dbi.Message);
               }
            }
         }
         Console.ReadLine();
      }
   }
}
```

输出：

```
Length: 4.5
Width: 7.5
Area: 33.75
Bug No: 49
Developer: Nuha Ali
Last Reviewed: 10/10/2012
Remarks: Unused variable
Bug No: 45
Developer: Zara Ali
Last Reviewed: 12/8/2012
Remarks: Return type mismatch
Bug No: 55, for Method: GetArea
Developer: Zara Ali
Last Reviewed: 19/10/2012
Remarks: Return type mismatch
Bug No: 56, for Method: Display
Developer: Zara Ali
Last Reviewed: 19/10/2012
Remarks: 
```

## C# 属性（Property）

**属性（Property）** 是类（class）、结构（structure）和接口（interface）的命名（named）成员。类或结构中的成员变量或方法称为 **域（Field）**。属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。它们使用 **访问器（accessors）** 让私有域的值可被读写或操作。

**主要作用：将读，写权限分开**。如果不使用属性，仅使用public, protected, private,这几个限制都是读，写属性一起的，可读就可写，不可读同时也不可写。不能实现只读不可写，只写不可读的需求。（java的get set 方法）
2，更好的安全性：可以在SET中通过条件判断来限制非法值等。（java的值检查注解）
这虽然可以通过函数来实现，但不如属性的调用简洁方便。
3，更高的灵活性：给属性赋值或取值时，Code可以对变量_code进行运算后得到（在get set 方法中）

属性（Property）不会确定存储位置。相反，它们具有可读写或计算它们值的 **访问器（accessors）**。

例如，有一个名为 Student 的类，带有 age、name 和 code 的私有域。我们不能在类的范围以外直接访问这些域，但是我们可以拥有访问这些私有域的属性。

### 访问器（Accessors）

属性（Property）的**访问器（accessor）**包含有助于获取（读取或计算）或设置（写入）属性的可执行语句。访问器（accessor）声明可包含一个 get 访问器、一个 set 访问器，或者同时包含二者。例如：

```
// 声明类型为 string 的 Code 属性
public string Code
{
   get
   {
      return code;
   }
   set
   {
      code = value;
   }
}
```

属性（Property）的用法：

```
using System;
namespace runoob
{
   class Student
   {

      private string code = "N.A";
      private string name = "not known";
      private int age = 0;

      // 声明类型为 string 的 Code 属性
      public string Code
      {
         get
         {
            return code;
         }
         set
         {
            code = value;
         }
      }
   
      // 声明类型为 string 的 Name 属性
      public string Name
      {
         get
         {
            return name;
         }
         set
         {
            name = value;
         }
      }

      // 声明类型为 int 的 Age 属性
      public int Age
      {
         get
         {
            return age;
         }
         set
         {
            age = value;
         }
      }
      public override string ToString()
      {
         return "Code = " + Code +", Name = " + Name + ", Age = " + Age;
      }
    }
    class ExampleDemo
    {
      public static void Main()
      {
         // 创建一个新的 Student 对象
         Student s = new Student();
            
         // 设置 student 的 code、name 和 age
         s.Code = "001";
         s.Name = "Zara";
         s.Age = 9;
         Console.WriteLine("Student Info: {0}", s);
         // 增加年龄
         s.Age += 1;
         Console.WriteLine("Student Info: {0}", s);
         Console.ReadKey();
       }
   }
}
```

抽象属性例子代码的简化版（使用C# 6.0 语言新特性）

```
using System;
namespace Demo.cs
{
    class Program
    {
        public abstract class Person
        {
            public abstract string Name { get; set; }
            public abstract int Age { get; set; }
        }
        public class Student : Person
        {
            public string Code { get; set; } = "N.A";
            public override string Name { get; set; } = "N.A";
            public override int Age { get; set; } = 0;
            public override string ToString()
            {
                return $"Code:{Code},Name:{Name},Age:{Age}";
            }
        }

        static void Main(string[] args)
        {
            var s = new Student()
            {
                Code = "001",
                Name = "Zara",
                Age = 10
            };
            System.Console.WriteLine($"Student Info:={s}");

            s.Age++;
            System.Console.WriteLine($"Student Info:={s}");
        }
    }
}
```

## C# 索引器（Indexer）

**索引器（Indexer）** 允许一个对象可以像数组一样使用下标的方式来访问。

当您为类定义一个索引器时，该类的行为就会像一个 **虚拟数组（virtual array）** 一样。您可以使用数组访问运算符 **[ ]** 来访问该类的的成员。

### 索引器（Indexer）的用途

索引器的行为的声明在某种程度上类似于属性（property）。就像属性（property），您可使用 **get** 和 **set** 访问器来定义索引器。但是，属性返回或设置一个特定的数据成员，而索引器返回或设置对象实例的一个特定值。换句话说，它把实例数据分为更小的部分，并索引每个部分，获取或设置每个部分。（为什么不直接操作数组？感觉没什么用）

定义一个属性（property）包括提供属性名称。索引器定义的时候不带有名称，但带有 **this** 关键字，它指向对象实例。下面的实例演示了这个概念：

```
using System;
namespace IndexerApplication
{
   class IndexedNames
   {
      private string[] namelist = new string[size];
      static public int size = 10;
      public IndexedNames()
      {
         for (int i = 0; i < size; i++)
         namelist[i] = "N. A.";
      }
      public string this[int index]
      {
         get
         {
            string tmp;

            if( index >= 0 && index <= size-1 )
            {
               tmp = namelist[index];
            }
            else
            {
               tmp = "";
            }

            return ( tmp );
         }
         set
         {
            if( index >= 0 && index <= size-1 )
            {
               namelist[index] = value;
            }
         }
      }

      static void Main(string[] args)
      {
         IndexedNames names = new IndexedNames();
         names[0] = "Zara";
         names[1] = "Riz";
         names[2] = "Nuha";
         names[3] = "Asif";
         names[4] = "Davinder";
         names[5] = "Sunil";
         names[6] = "Rubic";
         for ( int i = 0; i < IndexedNames.size; i++ )
         {
            Console.WriteLine(names[i]);
         }
         Console.ReadKey();
      }
   }
}
```

### 重载索引器（Indexer）

索引器（Indexer）可被重载。索引器声明的时候也可带有多个参数，且每个参数可以是不同的类型。没有必要让索引器必须是整型的。C# 允许索引器可以是其他类型，例如，字符串类型。

下面的实例演示了重载索引器：

```
using System;
namespace IndexerApplication
{
   class IndexedNames
   {
      private string[] namelist = new string[size];
      static public int size = 10;
      public IndexedNames()
      {
         for (int i = 0; i < size; i++)
         {
          namelist[i] = "N. A.";
         }
      }
      public string this[int index]
      {
         get
         {
            string tmp;

            if( index >= 0 && index <= size-1 )
            {
               tmp = namelist[index];
            }
            else
            {
               tmp = "";
            }

            return ( tmp );
         }
         set
         {
            if( index >= 0 && index <= size-1 )
            {
               namelist[index] = value;
            }
         }
      }
      public int this[string name]
      {
         get
         {
            int index = 0;
            while(index < size)
            {
               if (namelist[index] == name)
               {
                return index;
               }
               index++;
            }
            return index;
         }

      }

      static void Main(string[] args)
      {
         IndexedNames names = new IndexedNames();
         names[0] = "Zara";
         names[1] = "Riz";
         names[2] = "Nuha";
         names[3] = "Asif";
         names[4] = "Davinder";
         names[5] = "Sunil";
         names[6] = "Rubic";
         // 使用带有 int 参数的第一个索引器
         for (int i = 0; i < IndexedNames.size; i++)
         {
            Console.WriteLine(names[i]);
         }
         // 使用带有 string 参数的第二个索引器
         Console.WriteLine(names["Nuha"]);
         Console.ReadKey();
      }
   }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Zara
Riz
Nuha
Asif
Davinder
Sunil
Rubic
N. A.
N. A.
N. A.
2
```

## C# 委托（Delegate）

C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。**委托（Delegate）** 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。

委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 **System.Delegate** 类。

声明委托（Delegate）

委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。

例如，假设有一个委托：

```
public delegate int MyDelegate (string s);
```

上面的委托可被用于引用任何一个带有一个单一的 *string* 参数的方法，并返回一个 *int* 类型变量。

声明委托的语法如下：

```
delegate <return type> <delegate-name> <parameter list>
```

实例化委托（Delegate）

一旦声明了委托类型，委托对象必须使用 **new** 关键字来创建，且与一个特定的方法有关。当创建委托时，传递到 **new** 语句的参数就像方法调用一样书写，但是不带有参数。例如：

**public** **delegate** **void** printString(**string** s);
...
printString ps1 = new printString(WriteToScreen);
printString ps2 = new printString(WriteToFile);

下面的实例演示了委托的声明、实例化和使用，该委托可用于引用带有一个整型参数的方法，并返回一个整型值。

实例

```
using System;

delegate int NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }

      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      public static int getNum()
      {
         return num;
      }

      static void Main(string[] args)
      {
         // 创建委托实例
         NumberChanger nc;
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         nc = nc1;
         nc += nc2;
         // 调用多播
         nc(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Value of Num: 35
Value of Num: 175
```

委托的多播（Multicasting of a Delegate）

委托对象可使用 "+" 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。"-" 运算符可用于从合并的委托中移除组件委托。

使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的 **多播（multicasting）**，也叫组播。下面的程序演示了委托的多播：

实例

```
using System;

delegate int NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }

      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      public static int getNum()
      {
         return num;
      }

      static void Main(string[] args)
      {
         // 创建委托实例
         NumberChanger nc;
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         nc = nc1;
         nc += nc2;
         // 调用多播
         nc(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Value of Num: 75
```

委托（Delegate）的用途

下面的实例演示了委托的用法。委托 *printString* 可用于引用带有一个字符串作为输入的方法，并不返回任何东西。

我们使用这个委托来调用两个方法，第一个把字符串打印到控制台，第二个把字符串打印到文件：

实例

```
using System;
using System.IO;

namespace DelegateAppl
{
   class PrintString
   {
      static FileStream fs;
      static StreamWriter sw;
      // 委托声明
      public delegate void printString(string s);

      // 该方法打印到控制台
      public static void WriteToScreen(string str)
      {
         Console.WriteLine("The String is: {0}", str);
      }
      // 该方法打印到文件
      public static void WriteToFile(string s)
      {
         fs = new FileStream("c:\\message.txt", FileMode.Append, FileAccess.Write);
         sw = new StreamWriter(fs);
         sw.WriteLine(s);
         sw.Flush();
         sw.Close();
         fs.Close();
      }
      // 该方法把委托作为参数，并使用它调用方法
      public static void sendString(printString ps)
      {
         ps("Hello World");
      }
      static void Main(string[] args)
      {
         printString ps1 = new printString(WriteToScreen);
         printString ps2 = new printString(WriteToFile);
         sendString(ps1);
         sendString(ps2);
         Console.ReadKey();
      }
   }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
The String is: Hello World
```

## C# 事件（Event）

**事件（Event）** 基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。

C# 中使用事件机制实现线程间的通信。

通过事件使用委托

事件在类中声明且生成，且通过使用同一个类或其他类中的委托与事件处理程序关联。包含事件的类用于发布事件。这被称为 **发布器（publisher）** 类。其他接受该事件的类被称为 **订阅器（subscriber）** 类。事件使用 **发布-订阅（publisher-subscriber）** 模型。

**发布器（publisher）** 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。

**订阅器（subscriber）** 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）。

声明事件（Event）

在类的内部声明事件，首先必须声明该事件的委托类型。例如：

```
public delegate void BoilerLogHandler(string status);
```

然后，声明事件本身，使用 **event** 关键字：

```
// 基于上面的委托定义事件
public event BoilerLogHandler BoilerEventLog;
```

上面的代码定义了一个名为 *BoilerLogHandler* 的委托和一个名为 *BoilerEventLog* 的事件，该事件在生成的时候会调用委托。

实例

```
using System;
namespace SimpleEvent
{
  using System;
  /***********发布器类***********/
  public class EventTest
  {
    private int value;

    public delegate void NumManipulationHandler();


    public event NumManipulationHandler ChangeNum;
    protected virtual void OnNumChanged()
    {
      if ( ChangeNum != null )
      {
        ChangeNum(); /* 事件被触发 */
      }else {
        Console.WriteLine( "event not fire" );
        Console.ReadKey(); /* 回车继续 */
      }
    }


    public EventTest()
    {
      int n = 5;
      SetValue( n );
    }


    public void SetValue( int n )
    {
      if ( value != n )
      {
        value = n;
        OnNumChanged();
      }
    }
  }


  /***********订阅器类***********/

  public class subscribEvent
  {
    public void printf()
    {
      Console.WriteLine( "event fire" );
      Console.ReadKey(); /* 回车继续 */
    }
  }

  /***********触发***********/
  public class MainClass
  {
    public static void Main()
    {
      EventTest e = new EventTest(); /* 实例化对象,第一次没有触发事件 */
      subscribEvent v = new subscribEvent(); /* 实例化对象 */
      e.ChangeNum += new EventTest.NumManipulationHandler( v.printf ); /* 注册 */
      e.SetValue( 7 );
      e.SetValue( 11 );
    }
  }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
event not fire
event fire
event fire
```



理解：首先创建NumManipulationHandler，传入参数为订阅者的printf方法，事件NumManipulationHandler声名的委托是NumManipulationHandler（委托的参数和返回值和printf方法一致），当触发事件，委托执行订阅者对应的打印方法

## C# 集合（Collection）

集合（Collection）类是专门用于数据存储和检索的类。这些类提供了对栈（stack）、队列（queue）、列表（list）和哈希表（hash table）的支持。大多数集合类实现了相同的接口。

集合（Collection）类服务于不同的目的，如为元素动态分配内存，基于索引访问列表项等等。这些类创建 Object 类的对象的集合。在 C# 中，Object 类是所有数据类型的基类。

### List

```
var list=new List<int>();
```

首先，**List** 是个强类型，很安全。其次看那个尖括号，它是 C#2.0 时加入的泛型，所以并不存在像 **ArrayList**。

那样要拆/装箱以此造成性能浪费。

然后，**List** 通过索引分配，索引与数组一样，从 0 开始。它可以通过索引来读取值：

```
var a=new List<int>();
a.Add(12);
a.Add(10);
Console.WriteLine(a[0]);
```

列表可以有相同的项，而且项是手动排序。

在改变项后，要注意项的索引会发生改变：

```
var a=new List<int>();
a.Add(12);
a.Add(10);
Console.WriteLine(a[0]);
a.Remove(12);
Console.WriteLine(a[0]);
```

提供一下常用的列表方法：

-  1、**Add()** 将东西加入到列表的最后。
-  2、**Remove()** 删掉项中第一个匹配你想删除的条件的项（删去第一个匹配此条件的项）。
-  3、**Clear()** 清空所有项。
-  4、**Sort()** 用系统默认的方式对项进行排序。
-  5、**Contains()** 查看某项是否存在于列表中。

看例子：

```
using System;
using static System.Console;
using System.Collections.Generic;
namespace HelloWorldApplication
{
   class HelloWorld
   {
      static void Main(string[] args)
      {
          var a=new List<int>();
          a.Add(2);
          a.Add(6);
          a.Add(2);
          a.Add(10);
         Console.WriteLine($"第一个数为{a[0]}");
          a.Remove(2);//删去第一个匹配此条件的项
          a.Sort();
          foreach(var a2 in a)
          {
              WriteLine(a2);
          }
          bool a3=a.Contains(2);
          WriteLine(a3);
         Console.ReadKey();
      }
   }
}
```



### Dictionary

```
var a=new Dictionary<TKey,TValue>();
```

看见尖括号就知道它是c#2.0的泛型了，所以它可以容纳任何类型。

首先，字典有一个键<TKey>和一个值<TValue>,其中**键必须是唯一的，不能重复**。

**键不能是空引用**

其次我们可以用键来索引，就不用索引值来索引了。

```
WriteLine(a[TKey]);
```

来，介绍一下字典常用的东西

1 Add()：添加键和值

2 Clean()：清空字典中所有键和值

3 Count：获取字典中有多少对键和值

4 Remove() ：删掉一个键和值；

5—6：ContainsKey()/ContainsValue()：查看是否包含指定的键/值；

看例子：

```
using System;
using System.Collections.Generic;
namespace HelloWorldApplication
{
   class A
   {
      static void Main(string[] args)
      {
          var a=new Dictionary<int,int>();
          a.Add(12,14);
          a.Add(0,1);
          Console.WriteLine("删去前的Count"+a.Count);
          a.Remove(0);
          Console.WriteLine(a[12]);
          Console.WriteLine(a.Count);
         Console.WriteLine(a.ContainsKey(12));
         Console.ReadKey();
      }
   }
}
```

最后，**字典,堆栈，队列不能排序**，如果想对字典排序就要用其它方法或集合，如SortedDictionary<TKey,TValue>。

有很多种的自动排序，它们的性能有细微差异，所以要仔细选择最好的适合项目的自动排序集合

### ArrayList

*动态数组（ArrayList）基本上可以替代一个数组。但是，与数组不同的是，您可以使用***索引**在指定的位置添加和移除项目，动态数组会自动重新调整它的大小。它也允许在列表中进行动态内存分配、增加、搜索、排序各项。

常用的 **属性**：

| 属性           | 描述                                                  |
| :------------- | :---------------------------------------------------- |
| Capacity       | 获取或设置 ArrayList 可以包含的元素个数。             |
| Count          | 获取 ArrayList 中实际包含的元素个数。                 |
| IsFixedSize    | 获取一个值，表示 ArrayList 是否具有固定大小。         |
| IsReadOnly     | 获取一个值，表示 ArrayList 是否只读。                 |
| IsSynchronized | 获取一个值，表示访问 ArrayList 是否同步（线程安全）。 |
| Item[Int32]    | 获取或设置指定索引处的元素。                          |
| SyncRoot       | 获取一个对象用于同步访问 ArrayList。                  |

下表列出了 **ArrayList** 类的一些常用的 **方法**：

| 序号 | 方法名 & 描述                                                |
| :--- | :----------------------------------------------------------- |
| 1    | **public virtual int Add( object value );** 在 ArrayList 的末尾添加一个对象。 |
| 2    | **public virtual void AddRange( ICollection c );** 在 ArrayList 的末尾添加 ICollection 的元素。 |
| 3    | **public virtual void Clear();** 从 ArrayList 中移除所有的元素。 |
| 4    | **public virtual bool Contains( object item );** 判断某个元素是否在 ArrayList 中。 |
| 5    | **public virtual ArrayList GetRange( int index, int count );** 返回一个 ArrayList，表示源 ArrayList 中元素的子集。 |
| 6    | **public virtual int IndexOf(object);** 返回某个值在 ArrayList 中第一次出现的索引，索引从零开始。 |
| 7    | **public virtual void Insert( int index, object value );** 在 ArrayList 的指定索引处，插入一个元素。 |
| 8    | **public virtual void InsertRange( int index, ICollection c );** 在 ArrayList 的指定索引处，插入某个集合的元素。 |
| 9    | **public virtual void Remove( object obj );** 从 ArrayList 中移除第一次出现的指定对象。 |
| 10   | **public virtual void RemoveAt( int index );** 移除 ArrayList 的指定索引处的元素。 |
| 11   | **public virtual void RemoveRange( int index, int count );** 从 ArrayList 中移除某个范围的元素。 |
| 12   | **public virtual void Reverse();** 逆转 ArrayList 中元素的顺序。 |
| 13   | **public virtual void SetRange( int index, ICollection c );** 复制某个集合的元素到 ArrayList 中某个范围的元素上。 |
| 14   | **public virtual void Sort();** 对 ArrayList 中的元素进行排序。 |
| 15   | **public virtual void TrimToSize();** 设置容量为 ArrayList 中元素的实际个数。 |

```
using System;
using System.Collections;

namespace CollectionApplication
{
    class Program
    {
        static void Main(string[] args)
        {
            ArrayList al = new ArrayList();

            Console.WriteLine("Adding some numbers:");
            al.Add(45);
            al.Add(78);
            al.Add(33);
            al.Add(56);
            al.Add(12);
            al.Add(23);
            al.Add(9);
            
            Console.WriteLine("Capacity: {0} ", al.Capacity);
            Console.WriteLine("Count: {0}", al.Count);
                      
            Console.Write("Content: ");
            foreach (int i in al)
            {
                Console.Write(i + " ");
            }
            Console.WriteLine();
            Console.Write("Sorted Content: ");
            al.Sort();
            foreach (int i in al)
            {
                Console.Write(i + " ");
            }
            Console.WriteLine();
            Console.ReadKey();
        }
    }
}
```

```
当上面的代码被编译和执行时，它会产生下列结果：

Adding some numbers:
Capacity: 8 
Count: 7
Content: 45 78 33 56 12 23 9 
Sorted Content: 9 12 23 33 45 56 78 
```

会自动扩容，所以初始容量为8

#### 存储不同类型并排序

```
using System;
using System.Collections;

namespace CollectionApp
{
    class MyComparer : IComparer
    {
        public int Compare(object x, object y)
        {
            // 自定义比较规则
            // 如果x,y都是int，那么按正常流程比较
            // 如果其中一个不是int，那么认为不是int的值小
            // 如果都不是int，那么认为他们相等
            if (x is int)
            {
                if (y is int)
                {
                    if ((int)x < (int)y) return -1;
                    if ((int)x == (int)y) return 0;
                    return 1;
                }
                return 1;
            }
            if (y is int) return -1;
                return 0;
        }
    }

    class Entry
    {
        static void Print(ArrayList l)
        {
            Console.WriteLine("\t大小能力：{0}   实际大小：{1}", l.Capacity, l.Count);
            Console.Write("\t内容：");
            foreach (object obj in l)
            Console.Write("{0} ", obj);
            Console.Write("\r\n");
        }
        static void Main()
        {
            ArrayList l = new ArrayList();
            Console.WriteLine("添加一些不都是Int的数据：");
            l.Add(22);
            l.Add(77);
            l.Add("abc");
            l.Add(33);
            Print(l);
            Console.WriteLine("排序：");
            l.Sort(new MyComparer());
            Print(l);
            Console.ReadKey();
        }
    }
}
```

### Hashtable

代表了一系列基于键的哈希代码组织起来的**键/值**对。它使用**键**来访问集合中的元素。

当您使用**键**访问元素时，则使用哈希表，而且您可以识别一个有用的键值。哈希表中的每一项都有一个**键/值**对。键用于访问集合中的项目。

Hashtable 类的方法和属性

下表列出了 **Hashtable** 类的一些常用的 **属性**：

| 属性        | 描述                                          |
| :---------- | :-------------------------------------------- |
| Count       | 获取 Hashtable 中包含的键值对个数。           |
| IsFixedSize | 获取一个值，表示 Hashtable 是否具有固定大小。 |
| IsReadOnly  | 获取一个值，表示 Hashtable 是否只读。         |
| Item[key]   | 获取或设置与指定的键相关的值。                |
| Keys        | 获取一个 ICollection，包含 Hashtable 中的键。 |
| Values      | 获取一个 ICollection，包含 Hashtable 中的值。 |

下表列出了 **Hashtable** 类的一些常用的 **方法**：

| 序号 | 方法名 & 描述                                                |
| :--- | :----------------------------------------------------------- |
| 1    | **public virtual void Add( object key, object value );** 向 Hashtable 添加一个带有指定的键和值的元素。 |
| 2    | **public virtual void Clear();** 从 Hashtable 中移除所有的元素。 |
| 3    | **public virtual bool ContainsKey( object key );** 判断 Hashtable 是否包含指定的键。 |
| 4    | **public virtual bool ContainsValue( object value );** 判断 Hashtable 是否包含指定的值。 |
| 5    | **public virtual void Remove( object key );** 从 Hashtable 中移除带有指定的键的元素。 |



```
using System;
using System.Collections;

namespace CollectionsApplication
{
   class Program
   {
      static void Main(string[] args)
      {
         Hashtable ht = new Hashtable();


         ht.Add("001", "Zara Ali");
         ht.Add("002", "Abida Rehman");
         ht.Add("003", "Joe Holzner");
         ht.Add("004", "Mausam Benazir Nur");
         ht.Add("005", "M. Amlan");
         ht.Add("006", "M. Arif");
         ht.Add("007", "Ritesh Saikia");

         if (ht.ContainsValue("Nuha Ali"))
         {
            Console.WriteLine("This student name is already in the list");
         }
         else
         {
            ht.Add("008", "Nuha Ali");
         }
         string a = "001";
 		Console.WriteLine(ht[a]);
         // 获取键的集合 
         ICollection key = ht.Keys;

         foreach (string k in key)
         {
            Console.WriteLine(k + ": " + ht[k]);
         }
         Console.ReadKey();
      }
   }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
007: Ritesh Saikia
004: Mausam Benazir Nur
005: M. Amlan
008: Nuha Ali
002: Abida Rehman
003: Joe Holzner
001: Zara Ali
006: M. Arif
```

#### Hashtable、Dictionary比较

都是用的hash散列，Dictionary使用泛型没有装箱拆箱的性能损失，Hashtable存储的对象要转换为Object。

Hashtable支持多线程，Dictionary不支持

通常Dictionary性能好一些，但Hashtable支持多线程。



### SortedList

排序列表（SortedList）代表了一系列按照键来排序的**键/值**对，这些键值对可以通过键和索引来访问。

排序列表是数组和哈希表的组合。它包含一个可使用键或索引访问各项的列表。如果您使用索引访问各项，则它是一个动态数组（ArrayList），如果您使用键访问各项，则它是一个哈希表（Hashtable）。集合中的各项总是按键值排序。

下表列出了 **SortedList** 类的一些常用的 **属性**：

| 属性        | 描述                                           |
| :---------- | :--------------------------------------------- |
| Capacity    | 获取或设置 SortedList 的容量。                 |
| Count       | 获取 SortedList 中的元素个数。                 |
| IsFixedSize | 获取一个值，表示 SortedList 是否具有固定大小。 |
| IsReadOnly  | 获取一个值，表示 SortedList 是否只读。         |
| Item[key]   | 获取或设置与 SortedList 中指定的键相关的值。   |
| Item[Int32] | 获取或设置指定索引处的元素。                   |
| Keys        | 获取 SortedList 中的键。                       |
| Values      | 获取 SortedList 中的值。                       |

下表列出了 **SortedList** 类的一些常用的 **方法**：

| 序号 | 方法名 & 描述                                                |
| :--- | :----------------------------------------------------------- |
| 1    | **public virtual void Add( object key, object value );** 向 SortedList 添加一个带有指定的键和值的元素。 |
| 2    | **public virtual void Clear();** 从 SortedList 中移除所有的元素。 |
| 3    | **public virtual bool ContainsKey( object key );** 判断 SortedList 是否包含指定的键。 |
| 4    | **public virtual bool ContainsValue( object value );** 判断 SortedList 是否包含指定的值。 |
| 5    | **public virtual object GetByIndex( int index );** 获取 SortedList 的指定索引处的值。 |
| 6    | **public virtual object GetKey( int index );** 获取 SortedList 的指定索引处的键。 |
| 7    | **public virtual IList GetKeyList();** 获取 SortedList 中的键。 |
| 8    | **public virtual IList GetValueList();** 获取 SortedList 中的值。 |
| 9    | **public virtual int IndexOfKey( object key );** 返回 SortedList 中的指定键的索引，索引从零开始。 |
| 10   | **public virtual int IndexOfValue( object value );** 返回 SortedList 中的指定值第一次出现的索引，索引从零开始。 |
| 11   | **public virtual void Remove( object key );** 从 SortedList 中移除带有指定的键的元素。 |
| 12   | **public virtual void RemoveAt( int index );** 移除 SortedList 的指定索引处的元素。 |
| 13   | **public virtual void TrimToSize();** 设置容量为 SortedList 中元素的实际个数。 |



```
using System;
using System.Collections;

namespace CollectionsApplication
{
   class Program
   {
      static void Main(string[] args)
      {
         SortedList sl = new SortedList();

         sl.Add("001", "Zara Ali");
         sl.Add("002", "Abida Rehman");
         sl.Add("003", "Joe Holzner");
         sl.Add("004", "Mausam Benazir Nur");
         sl.Add("005", "M. Amlan");
         sl.Add("006", "M. Arif");
         sl.Add("007", "Ritesh Saikia");

         if (sl.ContainsValue("Nuha Ali"))
         {
            Console.WriteLine("This student name is already in the list");
         }
         else
         {
            sl.Add("008", "Nuha Ali");
         }

         // 获取键的集合 
         ICollection key = sl.Keys;

         foreach (string k in key)
         {
            Console.WriteLine(k + ": " + sl[k]);
         }
      }
   }
}
```

### Stack

堆栈（Stack）*代表了一个***后进先出***的对象集合。当您需要对各项进行后进先出的访问时，则使用堆栈。当您在列表中添加一项，称为***推入***元素，当您从列表中移除一项时，称为***弹出***元素。*

下表列出了 **Stack** 类的一些常用的 **属性**：

| 属性  | 描述                          |
| :---- | :---------------------------- |
| Count | 获取 Stack 中包含的元素个数。 |

下表列出了 **Stack** 类的一些常用的 **方法**：

| 序号 | 方法名 & 描述                                                |
| :--- | :----------------------------------------------------------- |
| 1    | **public virtual void Clear();** 从 Stack 中移除所有的元素。 |
| 2    | **public virtual bool Contains( object obj );** 判断某个元素是否在 Stack 中。 |
| 3    | **public virtual object Peek();** 返回在 Stack 的顶部的对象，但不移除它。 |
| 4    | **public virtual object Pop();** 移除并返回在 Stack 的顶部的对象。 |
| 5    | **public virtual void Push( object obj );** 向 Stack 的顶部添加一个对象。 |
| 6    | **public virtual object[] ToArray();** 复制 Stack 到一个新的数组中。 |

```
using System;
using System.Collections;

namespace CollectionsApplication
{
    class Program
    {
        static void Main(string[] args)
        {
            Stack st = new Stack();

            st.Push('A');
            st.Push('M');
            st.Push('G');
            st.Push('W');
            
            Console.WriteLine("Current stack: ");
            foreach (char c in st)
            {
                Console.Write(c + " ");
            }
            Console.WriteLine();
            
            st.Push('V');
            st.Push('H');
            Console.WriteLine("The next poppable value in stack: {0}", 
            st.Peek());
            Console.WriteLine("Current stack: ");           
            foreach (char c in st)
            {
               Console.Write(c + " ");
            }
            Console.WriteLine();

            Console.WriteLine("Removing values ");
            st.Pop();
            st.Pop();
            st.Pop();
            
            Console.WriteLine("Current stack: ");
            foreach (char c in st)
            {
               Console.Write(c + " "); 
            }
        }
    }
}
```

### Queue

*队列（Queue）代表了一个***先进先出***的对象集合。当您需要对各项进行先进先出的访问时，则使用队列。当您在列表中添加一项，称为***入队***，当您从列表中移除一项时，称为***出队***。*

下表列出了 **Queue** 类的一些常用的 **属性**：

| 属性  | 描述                          |
| :---- | :---------------------------- |
| Count | 获取 Queue 中包含的元素个数。 |

下表列出了 **Queue** 类的一些常用的 **方法**：

| 序号 | 方法名 & 描述                                                |
| :--- | :----------------------------------------------------------- |
| 1    | **public virtual void Clear();** 从 Queue 中移除所有的元素。 |
| 2    | **public virtual bool Contains( object obj );** 判断某个元素是否在 Queue 中。 |
| 3    | **public virtual object Dequeue();** 移除并返回在 Queue 的开头的对象。 |
| 4    | **public virtual void Enqueue( object obj );** 向 Queue 的末尾添加一个对象。 |
| 5    | **public virtual object[] ToArray();** 复制 Queue 到一个新的数组中。 |
| 6    | **public virtual void TrimToSize();** 设置容量为 Queue 中元素的实际个数。 |

### BitArray

BitArray 类管理一个紧凑型的位值数组，它使用布尔值来表示，其中 true 表示位是开启的（1），false 表示位是关闭的（0）。

当您需要存储位，但是事先不知道位数时，则使用点阵列。您可以使用**整型索引**从点阵列集合中访问各项，索引从零开始。

下表列出了 **BitArray** 类的一些常用的 **属性**：

| 属性       | 描述                                     |
| :--------- | :--------------------------------------- |
| Count      | 获取 BitArray 中包含的元素个数。         |
| IsReadOnly | 获取一个值，表示 BitArray 是否只读。     |
| Item       | 获取或设置 BitArray 中指定位置的位的值。 |
| Length     | 获取或设置 BitArray 中的元素个数。       |

下表列出了 **BitArray** 类的一些常用的 **方法**：

| 序号 | 方法名 & 描述                                                |
| :--- | :----------------------------------------------------------- |
| 1    | **public BitArray And( BitArray value );** 对当前的 BitArray 中的元素和指定的 BitArray 中的相对应的元素执行按位与操作。 |
| 2    | **public bool Get( int index );** 获取 BitArray 中指定位置的位的值。 |
| 3    | **public BitArray Not();** 把当前的 BitArray 中的位值反转，以便设置为 true 的元素变为 false，设置为 false 的元素变为 true。 |
| 4    | **public BitArray Or( BitArray value );** 对当前的 BitArray 中的元素和指定的 BitArray 中的相对应的元素执行按位或操作。 |
| 5    | **public void Set( int index, bool value );** 把 BitArray 中指定位置的位设置为指定的值。 |
| 6    | **public void SetAll( bool value );** 把 BitArray 中的所有位设置为指定的值。 |
| 7    | **public BitArray Xor( BitArray value );** 对当前的 BitArray 中的元素和指定的 BitArray 中的相对应的元素执行按位异或操作。 |

```
using System;
using System.Collections;

namespace CollectionsApplication
{
    class Program
    {
        static void Main(string[] args)
        {
            // 创建两个大小为 8 的点阵列
            BitArray ba1 = new BitArray(8);
            BitArray ba2 = new BitArray(8);
            byte[] a = { 60 };
            byte[] b = { 13 };
            
            // 把值 60 和 13 存储到点阵列中
            ba1 = new BitArray(a);
            ba2 = new BitArray(b);

            // ba1 的内容
            Console.WriteLine("Bit array ba1: 60");
            for (int i = 0; i < ba1.Count; i++)
            {
                Console.Write("{0, -6} ", ba1[i]);
            }
            Console.WriteLine();
            
            // ba2 的内容
            Console.WriteLine("Bit array ba2: 13");
            for (int i = 0; i < ba2.Count; i++)
            {
                Console.Write("{0, -6} ", ba2[i]);
            }
            Console.WriteLine();
           
            
            BitArray ba3 = new BitArray(8);
            ba3 = ba1.And(ba2);

            // ba3 的内容
            Console.WriteLine("Bit array ba3 after AND operation: 12");
            for (int i = 0; i < ba3.Count; i++)
            {
                Console.Write("{0, -6} ", ba3[i]);
            }
            Console.WriteLine();

            ba3 = ba1.Or(ba2);
            // ba3 的内容
            Console.WriteLine("Bit array ba3 after OR operation: 61");
            for (int i = 0; i < ba3.Count; i++)
            {
                Console.Write("{0, -6} ", ba3[i]);
            }
            Console.WriteLine();
            
            Console.ReadKey();
        }
    }
}
```

当上面的代码被编译和执行时，它会产生下列结果：数字转化为2进制，从左到右为2^0,2^1...

```
Bit array ba1: 60 
False False True True True True False False 
Bit array ba2: 13
True False True True False False False False 
Bit array ba3 after AND operation: 12
False False True True False False False False 
Bit array ba3 after OR operation: 61
True False True True False False False False 
```

## 泛型

使用泛型是一种增强程序功能的技术，具体表现在以下几个方面：

- 它有助于您最大限度地重用代码、保护类型的安全以及提高性能。
- 您可以创建泛型集合类。.NET 框架类库在 *System.Collections.Generic* 命名空间中包含了一些新的泛型集合类。您可以使用这些泛型集合类来替代 *System.Collections* 中的集合类。
- 您可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。
- 您可以对泛型类进行约束以访问特定数据类型的方法。
- 关于泛型数据类型中使用的类型的信息可在运行时通过使用反射获取。

### 泛型委托

如:delegate T NumberChanger<T>(T n);

```
using System;
using System.Collections.Generic;

delegate T NumberChanger<T>(T n);
namespace GenericDelegateAppl
{
    class TestDelegate
    {
        static int num = 10;
        public static int AddNum(int p)
        {
            num += p;
            return num;
        }

        public static int MultNum(int q)
        {
            num *= q;
            return num;
        }
        public static int getNum()
        {
            return num;
        }

        static void Main(string[] args)
        {
            // 创建委托实例
            NumberChanger<int> nc1 = new NumberChanger<int>(AddNum);
            NumberChanger<int> nc2 = new NumberChanger<int>(MultNum);
            // 使用委托对象调用方法
            nc1(25);
            Console.WriteLine("Value of Num: {0}", getNum());
            nc2(5);
            Console.WriteLine("Value of Num: {0}", getNum());
            Console.ReadKey();
        }
    }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Value of Num: 35
Value of Num: 175
```

## 匿名方法

委托是用于引用与其具有相同标签的方法。换句话说，您可以使用委托对象调用可由委托引用的方法。

**匿名方法（Anonymous methods）** 提供了一种传递代码块作为委托参数的技术。匿名方法是没有名称只有主体的方法。

在匿名方法中您不需要指定返回类型，它是从方法主体内的 return 语句推断的。

## 编写匿名方法的语法

匿名方法是通过使用 **delegate** 关键字创建委托实例来声明的。例如：

```
delegate void NumberChanger(int n);
...
NumberChanger nc = delegate(int x)
{
    Console.WriteLine("Anonymous Method: {0}", x);
};
```

代码块 **Console.WriteLine("Anonymous Method: {0}", x);** 是匿名方法的主体。

委托可以通过匿名方法调用，也可以通过命名方法调用，即，通过向委托对象传递方法参数。

**注意:** 匿名方法的主体后面需要一个 **;**。

### lambda 

在 C# 2.0 及更高版本中，引入了 lambda 表达式，它是一种更简洁的语法形式，用于编写匿名方法。

使用 lambda 表达式：

```
using System;

delegate void NumberChanger(int n);

namespace DelegateAppl
{
    class TestDelegate
    {
        static int num = 10;

        public static void AddNum(int p)
        {
            num += p;
            Console.WriteLine("Named Method: {0}", num);
        }

        public static void MultNum(int q)
        {
            num *= q;
            Console.WriteLine("Named Method: {0}", num);
        }

        static void Main(string[] args)
        {
            // 使用 lambda 表达式创建委托实例
            NumberChanger nc = x => Console.WriteLine($"Lambda Expression: {x}");

            // 使用 lambda 表达式调用委托
            nc(10);

            // 使用命名方法实例化委托
            nc = new NumberChanger(AddNum);

            // 使用命名方法调用委托
            nc(5);

            // 使用另一个命名方法实例化委托
            nc = new NumberChanger(MultNum);

            // 使用命名方法调用委托
            nc(2);

            Console.ReadKey();
        }
    }
}
```

## 不安全代码

当一个代码块使用 **unsafe** 修饰符标记时，C# 允许在函数中使用指针变量。**不安全代码**或非托管代码是指使用了**指针**变量的代码块。

### 指针变量

**指针** 是值为另一个变量的地址的变量，即，内存位置的直接地址。就像其他变量或常量，您必须在使用指针存储其他变量地址之前声明指针。

指针变量声明的一般形式为：

```
type* var-name;
```

下面是指针类型声明的实例：

| 实例        | 描述                             |
| :---------- | :------------------------------- |
| `int* p`    | `p` 是指向整数的指针。           |
| `double* p` | `p` 是指向双精度数的指针。       |
| `float* p`  | `p` 是指向浮点数的指针。         |
| `int** p`   | `p` 是指向整数的指针的指针。     |
| `int*[] p`  | `p` 是指向整数的指针的一维数组。 |
| `char* p`   | `p` 是指向字符的指针。           |
| `void* p`   | `p` 是指向未知类型的指针。       |

在同一个声明中声明多个指针时，星号 ***** 仅与基础类型一起写入；而不是用作每个指针名称的前缀。 例如:

```
int* p1, p2, p3;     // 正确  
int *p1, *p2, *p3;   // 错误 
```

下面的实例说明了 C# 中使用了 **unsafe** 修饰符时指针的使用：

```
using System;
namespace UnsafeCodeApplication
{
    class Program
    {
        static unsafe void Main(string[] args)
        {
            int var = 20;
            int* p = &var;
            Console.WriteLine("Data is: {0} ",  var);
            Console.WriteLine("Address is: {0}",  (int)p);
            Console.ReadKey();
        }
    }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Data is: 20
Address is: 99215364
```

### 使用指针检索数据值

您可以使用 **ToString()** 方法检索存储在指针变量所引用位置的数据。下面的实例演示了这点：

```
using System;
namespace UnsafeCodeApplication
{
   class Program
   {
      public static void Main()
      {
         unsafe
         {
            int var = 20;
            int* p = &var;
            Console.WriteLine("Data is: {0} " , var);
            Console.WriteLine("Data is: {0} " , p->ToString());
            Console.WriteLine("Address is: {0} " , (int)p);
         }
         Console.ReadKey();
      }
   }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Data is: 20
Data is: 20
Address is: 77128984
```

### 使用指针访问数组元素

在 C# 中，数组名称和一个指向与数组数据具有相同数据类型的指针是不同的变量类型。例如，int *p 和 int[] p 是不同的类型。您可以增加指针变量 p，因为它在内存中不是固定的，但是数组地址在内存中是固定的，所以您不能增加数组 p。

因此，如果您需要使用指针变量访问数组数据，可以像我们通常在 C 或 C++ 中所做的那样，使用 **fixed** 关键字来固定指针。

下面的实例演示了这点：

```
using System;
namespace UnsafeCodeApplication
{
   class TestPointer
   {
      public unsafe static void Main()
      {
         int[]  list = {10, 100, 200};
         fixed(int *ptr = list)

         /* 显示指针中数组地址 */
         for ( int i = 0; i < 3; i++)
         {
            Console.WriteLine("Address of list[{0}]={1}",i,(int)(ptr + i));
            Console.WriteLine("Value of list[{0}]={1}", i, *(ptr + i));
         }
         Console.ReadKey();
      }
   }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Address of list[0] = 31627168
Value of list[0] = 10
Address of list[1] = 31627172
Value of list[1] = 100
Address of list[2] = 31627176
Value of list[2] = 200
```

### 编译不安全代码

为了编译不安全代码，您必须切换到命令行编译器指定 **/unsafe** 命令行。

例如，为了编译包含不安全代码的名为 prog1.cs 的程序，需在命令行中输入命令：

```
csc /unsafe prog1.cs
```

如果您使用的是 Visual Studio IDE，那么您需要在项目属性中启用不安全代码。

步骤如下：

- 通过双击资源管理器（Solution Explorer）中的属性（properties）节点，打开**项目属性（project properties）**。
- 点击 **Build** 标签页。
- 选择选项"**Allow unsafe code**"。



## 多线程

### 线程生命周期

线程生命周期开始于 System.Threading.Thread 类的对象被创建时，结束于线程被终止或完成执行时。

下面列出了线程生命周期中的各种状态：

- **未启动状态**：当线程实例被创建但 Start 方法未被调用时的状况。

- **就绪状态**：当线程准备好运行并等待 CPU 周期时的状况。

- 不可运行状态

  ：下面的几种情况下线程是不可运行的：

  - 已经调用 Sleep 方法
  - 已经调用 Wait 方法
  - 通过 I/O 操作阻塞

- **死亡状态**：当线程已完成执行或已中止时的状况。

主线程

在 C# 中，**System.Threading.Thread** 类用于线程的工作。它允许创建并访问多线程应用程序中的单个线程。进程中第一个被执行的线程称为**主线程**。

当 C# 程序开始执行时，主线程自动创建。使用 **Thread** 类创建的线程被主线程的子线程调用。您可以使用 Thread 类的 **CurrentThread** 属性访问线程。

下面的程序演示了主线程的执行：

```
using System;
using System.Threading;

namespace MultithreadingApplication
{
    class MainThreadProgram
    {
        static void Main(string[] args)
        {
            Thread th = Thread.CurrentThread;
            th.Name = "MainThread";
            Console.WriteLine("This is {0}", th.Name);
            Console.ReadKey();
        }
    }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
This is MainThread
```

### Thread 类常用的属性和方法

下表列出了 **Thread** 类的一些常用的 **属性**：

| 属性               | 描述                                                         |
| :----------------- | :----------------------------------------------------------- |
| CurrentContext     | 获取线程正在其中执行的当前上下文。                           |
| CurrentCulture     | 获取或设置当前线程的区域性。                                 |
| CurrentPrincipal   | 获取或设置线程的当前负责人（对基于角色的安全性而言）。       |
| CurrentThread      | 获取当前正在运行的线程。                                     |
| CurrentUICulture   | 获取或设置资源管理器使用的当前区域性以便在运行时查找区域性特定的资源。 |
| ExecutionContext   | 获取一个 ExecutionContext 对象，该对象包含有关当前线程的各种上下文的信息。 |
| IsAlive            | 获取一个值，该值指示当前线程的执行状态。                     |
| IsBackground       | 获取或设置一个值，该值指示某个线程是否为后台线程。           |
| IsThreadPoolThread | 获取一个值，该值指示线程是否属于托管线程池。                 |
| ManagedThreadId    | 获取当前托管线程的唯一标识符。                               |
| Name               | 获取或设置线程的名称。                                       |
| Priority           | 获取或设置一个值，该值指示线程的调度优先级。                 |
| ThreadState        | 获取一个值，该值包含当前线程的状态。                         |

下表列出了 **Thread** 类的一些常用的 **方法**：

| 序号 | 方法名 & 描述                                                |
| :--- | :----------------------------------------------------------- |
| 1    | **public void Abort()** 在调用此方法的线程上引发 ThreadAbortException，以开始终止此线程的过程。调用此方法通常会终止线程。 |
| 2    | **public static LocalDataStoreSlot AllocateDataSlot()** 在所有的线程上分配未命名的数据槽。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。 |
| 3    | **public static LocalDataStoreSlot AllocateNamedDataSlot( string name)** 在所有线程上分配已命名的数据槽。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。 |
| 4    | **public static void BeginCriticalRegion()** 通知主机执行将要进入一个代码区域，在该代码区域内线程中止或未经处理的异常的影响可能会危害应用程序域中的其他任务。 |
| 5    | **public static void BeginThreadAffinity()** 通知主机托管代码将要执行依赖于当前物理操作系统线程的标识的指令。 |
| 6    | **public static void EndCriticalRegion()** 通知主机执行将要进入一个代码区域，在该代码区域内线程中止或未经处理的异常仅影响当前任务。 |
| 7    | **public static void EndThreadAffinity()** 通知主机托管代码已执行完依赖于当前物理操作系统线程的标识的指令。 |
| 8    | **public static void FreeNamedDataSlot(string name)** 为进程中的所有线程消除名称与槽之间的关联。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。 |
| 9    | **public static Object GetData( LocalDataStoreSlot slot )** 在当前线程的当前域中从当前线程上指定的槽中检索值。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。 |
| 10   | **public static AppDomain GetDomain()** 返回当前线程正在其中运行的当前域。 |
| 11   | **public static AppDomain GetDomainID()** 返回唯一的应用程序域标识符。 |
| 12   | **public static LocalDataStoreSlot GetNamedDataSlot( string name )** 查找已命名的数据槽。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。 |
| 13   | **public void Interrupt()** 中断处于 WaitSleepJoin 线程状态的线程。 |
| 14   | **public void Join()** 在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻塞调用线程，直到某个线程终止为止。此方法有不同的重载形式。 |
| 15   | **public static void MemoryBarrier()** 按如下方式同步内存存取：执行当前线程的处理器在对指令重新排序时，不能采用先执行 MemoryBarrier 调用之后的内存存取，再执行 MemoryBarrier 调用之前的内存存取的方式。 |
| 16   | **public static void ResetAbort()** 取消为当前线程请求的 Abort。 |
| 17   | **public static void SetData( LocalDataStoreSlot slot, Object data )** 在当前正在运行的线程上为此线程的当前域在指定槽中设置数据。为了获得更好的性能，请改用以 ThreadStaticAttribute 属性标记的字段。 |
| 18   | **public void Start()** 开始一个线程。                       |
| 19   | **public static void Sleep( int millisecondsTimeout )** 让线程暂停一段时间。 |
| 20   | **public static void SpinWait( int iterations )** 导致线程等待由 iterations 参数定义的时间量。 |
| 21   | **public static byte VolatileRead( ref byte address ) public static double VolatileRead( ref double address ) public static int VolatileRead( ref int address ) public static Object VolatileRead( ref Object address )** 读取字段值。无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。此方法有不同的重载形式。这里只给出了一些形式。 |
| 22   | **public static void VolatileWrite( ref byte address, byte value ) public static void VolatileWrite( ref double address, double value ) public static void VolatileWrite( ref int address, int value ) public static void VolatileWrite( ref Object address, Object value )** 立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。此方法有不同的重载形式。这里只给出了一些形式。 |
| 23   | **public static bool Yield()** 导致调用线程执行准备好在当前处理器上运行的另一个线程。由操作系统选择要执行的线程。 |



### 创建线程

线程是通过扩展 Thread 类创建的。扩展的 Thread 类调用 **Start()** 方法来开始子线程的执行。

下面的程序演示了这个概念：

```
using System;
using System.Threading;

namespace MultithreadingApplication
{
    class ThreadCreationProgram
    {
        public static void CallToChildThread()
        {
            Console.WriteLine("Child thread starts");
        }
        
        static void Main(string[] args)
        {
            ThreadStart childref = new ThreadStart(CallToChildThread);
            Console.WriteLine("In Main: Creating the Child thread");
            Thread childThread = new Thread(childref);
            childThread.Start();
            Console.ReadKey();
        }
        
    }
}
```

```
Thread childThread = new Thread( new ThreadStart(CallToChildThread));

Thread childThread = new Thread(CallToChildThread);
```

这两种写法的效果是一样的。都是创建一个线程。后者只是 C# 的语法，编译时编译器会自动转换成第一种的形式。ThreadStart 是线程的入口，可以理解为一个函数指针，指向线程将要运行的函数。使用delegate实现。

当上面的代码被编译和执行时，它会产生下列结果：

```
In Main: Creating the Child thread
Child thread starts
```

- 1.Thread 自己创建的独立的线程, 优先级高,需要使用者自己管理。
-  2.ThreadPool 由 .Net 自己管理, 只需要把需要处理的方法写好, 然后交给.Net Framework, 后续只要方法执行完毕, 则自动退出。
-  3.Task 4.0 以后新增的线程操作方式, 类似 ThreadPool, 但效率测试比ThreadPool略高, Task对多核的支持更为明显,所以在多核的处理器中, Task的优势更为明显。

```
class Program
{  
    static void Main(string[] args)
    {  //独立创建线程
        Thread t = new Thread(ThreadProcess);
        t.Start(new object());
        
        //线程池
        ThreadPool.QueueUserWorkItem(ThreadProcess, new object());
        //Task方式创建线程
        System.Threading.Tasks.Task.Factory.StartNew(ThreadProcess, new object());

        //需要手动终止,当然现在终止可能线程还未运行完成,
        t.Abort();
    }
    private static void ThreadProcess(object tag)
    {
        int i = 100;
        while (i > 0)
        {
            Console.WriteLine(string.Format("i:{0} ", i));
            Thread.Sleep(10);
            i--;
        }
    }
}
```





### 带参数的线程

线程函数通过委托传递，可以不带参数，也可以带参数（只能有一个参数），可以用一个类或结构体封装参数:

```
using System;
using System.Threading;

namespace Test
{
    class Program
    {
        static void Main(string[] args)
        {
            Thread t1 = new Thread(new ThreadStart(TestMethod));
            Thread t2 = new Thread(new ParameterizedThreadStart(TestMethod));
            t1.IsBackground = true;
            t2.IsBackground = true;
            t1.Start();
            t2.Start("hello");
            Console.ReadKey();
        }

        public static void TestMethod()
        {
            Console.WriteLine("不带参数的线程函数");
        }

        public static void TestMethod(object data)
        {
            string datastr = data as string;
            Console.WriteLine("带参数的线程函数，参数为：{0}", datastr);
        }
    }
}
```

### ThreadPool 

### Task 



## 匿名方法

delegate 关键字后加上参数的声明和方法体：



```csharp
            Transformer sqr = delegate(int i) { return i * i; };
            Console.WriteLine(sqr(12));
            Transformer sqrLambda = x => x * x;
            Console.WriteLine(sqrLambda(2));
```

## 扩展方法

扩展方法允许在现有类型上扩展新的方法而无须修改原始类型的定义，是静态类的静态方法.



```cpp
    public static class StringHelper
    {
        public static bool isCapitalized(this string s)
        {
            if (string.IsNullOrEmpty(s)) return false;
            return char.IsUpper(s[0]);
        }
    }
    
    ...
    
    Console.WriteLine("Afra55".isCapitalized()); // True
    Console.WriteLine("afra55".isCapitalized()); // False
```

## 匿名类型

new 关键字加上对象初始化器：



```csharp
            // 只能通过 var 引用
            var person = new {Name = "Afra55", Age = 20};
            var person1 = new {Name = "Afra55", Age = 20};
            Console.WriteLine(person  == person1); // False
            Console.WriteLine(person.Equals(person1)); // True
            Console.WriteLine(person.GetType() == person1.GetType()); // True
```

## 元组



```csharp
            // 元组元素可以简单的在括号中初始化值
            var user = ("Bfra55", 10);
            Console.WriteLine(user.Item1);  // Bfra55
            Console.WriteLine(user.Item2);  // 10

            // 元组是值类型，可以指定元组元素类型
            (string, long) u = ("Bfra55", 20);

            // 可以为元素定义名字
            var u1 = (Name: "Cfra55", Age: 22);
            Console.WriteLine(u1.Name);
            Console.WriteLine(u1.Age);

            (string Name, int Age) u2 = ("Dfra55", 22);
            Console.WriteLine(u2.Equals(u1)); // True
```

## 动态绑定

动态绑定将解析类型、成员和操作的过程从编译时延迟到运行时。



```csharp
        class User
        {
            private int age;
            private string name;

            public int Age
            {
                get => age;
                set => age = value;
            }

            public string Name
            {
                get => name;
                set => name = value;
            }

            public void ShowInfo()
            {
                Console.WriteLine( $"{Age}, {Name}");
            }
        }

        public static void Test5()
        {
            // 动态绑定
            dynamic d = new User();
            // 编译时并不知道 d 有 ShowInfo 方法，在运行时才会去查找这个方法
            d.Name = "Afra55";
            d.Age = 123;
            d.ShowInfo(); // 123, Afra55
            // 当方法不存在时就会抛出异常
            d.WhatDoYouDo(); // Microsoft.CSharp.RuntimeBinder.RuntimeBinderException:
        }
```

### 自定义绑定

避免方法不存在时抛出异常可以让类继承 DynamicObject, 并重写 TryInvokeMember 方法：



```csharp
       class User : DynamicObject
        {
            private int age;
            private string name;

            public int Age
            {
                get => age;
                set => age = value;
            }

            public string Name
            {
                get => name;
                set => name = value;
            }

            public void ShowInfo()
            {
                Console.WriteLine( $"{Age}, {Name}");
            }

            public override bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)
            {
                Console.WriteLine(binder.Name + " method was called");
                result = null;
                return true;
                // return base.TryInvokeMember(binder, args, out result);
            }
        }

        public static void Test5()
        {
            // 动态绑定
            dynamic d = new User();
            // 编译时并不知道 d 有 ShowInfo 方法，在运行时才会去查找这个方法
            d.Name = "Afra55";
            d.Age = 123;
            d.ShowInfo();
            d.WhatDoYouDo(); // WhatDoYouDo method was called
        }
```

动态绑定失去了静态绑定时的类型安全保证，可能出现运行时异常：



```csharp
        // 参数动态绑定，返回值也动态绑定，失去了类型安全的保护，可能发生运行时异常
        static dynamic Mean(dynamic x, dynamic y) => (x + y) / 2;
        public static void Test6()
        {
            int x = 3, y = 4;
            Console.WriteLine(Mean(x, y));
            Console.WriteLine(Mean(x, "22")); // .RuntimeBinderException
        }
```

动态引用可以指向 指针类型以外的任何类型对象：



```csharp
            dynamic x = "Afra55";
            Console.WriteLine(x.GetType().Name); // String
            x = 32;
            Console.WriteLine(x.GetType().Name); // Int32
```

var 是用编译器确定类型；
 dynamic 是运行时确定类型。





## async await

简单介绍
在C#中，在很多的时候，都需要一些异步操作，并且在做完这些异步操作之后，可以在后面接着做一些处理，在 .net framework 4.5之后，便加入了一种简洁的方式来使用异步操作，这就是async和await。
async用来声明一个函数体，将其声明为异步方法，而await则是用在这个函数体的内部，用于等待一个异步操作的完成。
异步方法内部可以出现一个或者多个await，一般不要是0个，这样就失去了异步方法的意义了。

https://blog.csdn.net/sinolover/article/details/110086269

一个异步方法中有多个await，那么第二个await是等第一个await的新的线程来发起的，原来的主线程不会发起第二个子线程。

```
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Threading;
using System;
using static System.Net.Mime.MediaTypeNames;

namespace TodoApi
{
    public class AwaitTest
    {
        public int Write(object parameters)
        {
            if (parameters is List<object> parameterList && parameterList.Count >= 2)
            {
                int milliSeconds = Convert.ToInt32(parameterList[0]);
                string message = Convert.ToString(parameterList[1]);
                string flag = Convert.ToString(parameterList[2]);

                // 打印当前线程的名称
                if (string.IsNullOrEmpty(Thread.CurrentThread.Name))
                {
                    Thread.CurrentThread.Name = $"任务线程_{flag}";
                }
                Console.WriteLine($"------Write()-------，运行于线程：{Thread.CurrentThread.Name}");

                if (milliSeconds <= 0 || string.IsNullOrEmpty(message))
                {
                    return 0;
                }
                string time1 = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                Thread.Sleep(milliSeconds);
                string time2 = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");

                // 打印消息
                string content = $"    从 {time1} 至 {time2}：{message}";
                Console.WriteLine(content);

                // 返回消息的长度
                return content.Length;
            }
            return -1;
        }

        // 返回 void
        public async void Call_Await()
        {
            // 调用方调用之前
            if (string.IsNullOrEmpty(Thread.CurrentThread.Name))
            {
                Thread.CurrentThread.Name = "CallAwaitMethodThread1";
            }
            Console.WriteLine($"-在调用异步方法之前-，运行于线程：{Thread.CurrentThread.Name}");

            // 调用方调用
            await RunAsync1();

            // 调用方调用之后
            if (string.IsNullOrEmpty(Thread.CurrentThread.Name))
            {
                Thread.CurrentThread.Name = "CallAwaitMethodThread2";
            }
            Console.WriteLine($"-在调用异步方法之后1，运行于线程：{Thread.CurrentThread.Name}");
        }

        // 返回 Task<int>
        public async Task<int> RunAsync1()
        {
            // 第一个 await 之前的代码
            Task<int> task1 = new Task<int>(Write, new List<object>() { 1000, "test", "1st" });
            task1.Start();

            if (string.IsNullOrEmpty(Thread.CurrentThread.Name))
            {
                Thread.CurrentThread.Name = "RunAsyncMethodThread1";
            }
            Console.WriteLine($"--await--之前的代码1，运行于线程：{Thread.CurrentThread.Name}");

            await task1;

            // await 之间的代码
            Task<int> task2 = new Task<int>(Write, new List<object>() { 1000, "test", "2nd" });
            task2.Start();

            if (string.IsNullOrEmpty(Thread.CurrentThread.Name))
            {
                Thread.CurrentThread.Name = "RunAsyncMethodThread2";
            }
            Console.WriteLine($"--await--之间的代码1，运行于线程：{Thread.CurrentThread.Name}");

            await task2;

            // 最后一个 await 之后的代码
            if (string.IsNullOrEmpty(Thread.CurrentThread.Name))
            {
                Thread.CurrentThread.Name = "RunAsyncMethodThread3";
            }
            Console.WriteLine($"--await--之后的代码1，运行于线程：{Thread.CurrentThread.Name}");

            return task1.Result + task2.Result;
        }

        static void Main(string[] args)
        {
            try
            {
                Thread.CurrentThread.Name = "主线程";
                Console.WriteLine($"-------Main()-------，运行于线程：{Thread.CurrentThread.Name}");

                AwaitTest test = new AwaitTest();
                test.Call_Await();
                if (string.IsNullOrEmpty(Thread.CurrentThread.Name))
                {
                    Thread.CurrentThread.Name = "MainTryThread1";
                }
                Console.WriteLine($"--------Try---------，运行于线程：{Thread.CurrentThread.Name}");
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
            finally
            {
                if (string.IsNullOrEmpty(Thread.CurrentThread.Name))
                {
                    Thread.CurrentThread.Name = "MainFinallyThread";
                }
                Console.WriteLine($"------Finally-------，运行于线程：{Thread.CurrentThread.Name}");

                Console.ReadKey();
            }
        }
    }
}
```

输出：

-------Main()-------，运行于线程：主线程
-在调用异步方法之前-，运行于线程：主线程
--await--之前的代码1，运行于线程：主线程
--------Try---------，运行于线程：主线程
------Finally-------，运行于线程：主线程
------Write()-------，运行于线程：任务线程_1st
    从 2023-08-08 14:46:59.313 至 2023-08-08 14:47:00.328：test
--await--之间的代码1，运行于线程：任务线程_1st
------Write()-------，运行于线程：任务线程_2nd
    从 2023-08-08 14:47:00.336 至 2023-08-08 14:47:01.345：test
--await--之后的代码1，运行于线程：任务线程_2nd
-在调用异步方法之后1，运行于线程：任务线程_2nd





# .net 

**.NET**

## .Net 框架（.Net Framework）

.Net 框架是一个创新的平台，能帮您编写出下面类型的应用程序：

- Windows 应用程序
- Web 应用程序
- Web 服务

.Net 框架应用程序是多平台的应用程序。框架的设计方式使它适用于下列各种语言：C#、C++、Visual Basic、Jscript、COBOL 等等。所有这些语言可以访问框架，彼此之间也可以互相交互。

.Net 框架由一个巨大的代码库组成，用于 C# 等客户端语言。下面列出一些 .Net 框架的组件：

- 公共语言运行库（Common Language Runtime - CLR）
- .Net 框架类库（.Net Framework Class Library）
- 公共语言规范（Common Language Specification）
- 通用类型系统（Common Type System）
- 元数据（Metadata）和组件（Assemblies）
- Windows 窗体（Windows Forms）
- ASP.Net 和 ASP.Net AJAX
- ADO.Net
- Windows 工作流基础（Windows Workflow Foundation - WF）
- Windows 显示基础（Windows Presentation Foundation）
- Windows 通信基础（Windows Communication Foundation - WCF）
- LINQ

## .NET Framework 3.5

官网：https://learn.microsoft.com/zh-cn/previous-versions/dotnet/netframework-3.5/w0x726c2(v=vs.90)

> **2002年**微软发布了 **.NET Framework** 的第一个版本 .Net framework 1.0。主要用于搭建可以在 Windows 平台上运行的应用程序，其中包括 Web 、Windows 和移动端的各种应用程序。公共语言运行时（CLR）和类库是组成 .NET Framework 的两个主要组件。截至目前，.NET Framework 的最新版本为 4.8.1， 4.6.1 之前的版本微软已经停止支持。

.NET Framework 具有两个主要组件：公共语言运行库和 .NET Framework 类库。

公共语言运行库是 .NET Framework 的基础。管理内存、线程执行、代码执行、代码安全验证、编译以及其他系统服务。以运行库为目标的代码称为托管代码，而不以运行库为目标的代码称为非托管代码。

类库：是一个综合性的面向对象的可重用类型集合，您可以使用它开发多种应用程序，这些应用程序包括传统的命令行或图形用户界面 (GUI) 应用程序，也包括基于 ASP.NET 所提供的最新创新的应用程序（如 Web 窗体和 XML Web Services）。

![image-20230809101459172](D:\stu\java\java markdown\image\image-20230809101459172.png)

### ASP.NET

https://blog.csdn.net/weixin_61361738/article/details/129906567

在vs中创建见上面链接

ASP.NET 是 .NET Framework 的一部分，可提供用于创建动态 Web 应用程序的类和工具。本节中的主题指导您创建、编写和部署 ASP.NET Web 应用程序。

#### 项目目录

Properties： 包含了项目的配置文件和资源文件。其中，AssemblyInfo.cs 文件用于描述程序集的元数据信息，包括版本号、公司名称、版权信息等。这些文件可以帮助程序员轻松管理和配置项目。
引用： 指项目所依赖的外部二进制组件库（如 DLL 文件），这些组件库包含了程序执行所需要的函数、类、接口等等。当项目需要使用这些组件时，需要先将它们添加到引用列表中。通过引用，项目可以访问这些外部组件并调用其中的方法或属性，从而实现更加丰富的功能。通常，引用可以在 Visual Studio 中管理，在项目的“引用”节点下添加、删除、更新等。
![image-20230809104210962](D:\stu\java\java markdown\image\image-20230809104210962.png)

2.2、应用程序文件
App_Data： 通常用于存储应用程序的数据文件，如 XML 文件、数据库文件、日志文件等等。这些文件不应该直接被访问，而是由应用程序来操作这些文件。例如，应用程序可以读取 XML 文件中的数据、从数据库文件中查询数据、写入日志文件等等。 通常情况下，App_Data 文件夹中的文件不应该包含代码或其他程序文件，而是应该只包含数据和配置信息。这样可以更好地分离代码和数据，便于应用程序的管理和维护。

App_Start： 通常包含用于启动应用程序的配置、路由、日志等等相关代码。例如，BundleConfig.cs 文件用于配置 JavaScript 和 CSS 文件的 Bundle，在应用程序启动时会被自动执行；FilterConfig.cs 文件用于配置全局的 Action Filter，会在应用程序启动时被自动注册，注册Action和Controller的过滤器的；RouteConfig.cs 文件用于配置应用程序的路由规则，也会在应用程序启动时被自动调用等等。App_Start 文件夹在程序启动之前执行应用程序的配置和初始化，从而保证应用程序的正常运行。 注意：4.0版本才有。

Content： 通常用于存储应用程序的静态资源文件，如 CSS 样式表、图片、JavaScript 文件等等。这些静态资源文件可以通过 URL 来访问，通常是通过视图文件或布局文件来引用，以便于页面呈现和交互效果的实现。需要注意的是，Content 文件夹中的静态资源文件通常不会包含动态代码，如服务器端代码、JavaScript 表达式等等。这些静态资源文件只是应用程序的静态展示内容，是客户端浏览器可以直接解释和呈现的内容。

![image-20230809111329854](D:\stu\java\java markdown\image\image-20230809111329854.png)

Controllers： 包含处理来自客户端浏览器请求并生成响应的控制器类文件。这些类通常包含多个操作方法，每个操作对应着一个 HTTP 请求类型，如GET 、POST 、PUT 等。控制器通过模型交互来响应 Web UI 的用户动作，从而实现模型、视图、控制器之间的协作。控制器处理客户端的请求，从模型中检索数据并将响应提交到视图，最后再输出回客户端。Controllers 文件夹中包含一些ASP.NET MVC应用程序可用的基础控制器，例如：HomeController 等。

![image-20230809113724468](D:\stu\java\java markdown\image\image-20230809113724468.png)

fonts： 是 Web 应用程序中用于保存网站所需字体文件的文件夹。在许多Web 站点中，定制字体已成为设计趋势。由于常用字体可能会在用户的系统中缺少，因此，网站通常会将自定义字体文件包括在 Fonts 文件夹中，以确保字体在用户设备中正确地显示。

Models： 一个用于存放各种数据模型的文件夹，也就是其中包含了表示应用程序中的数据结构的类。这些模型类可以与数据库中的表对应起来，也可以用来表示复杂的数据结构。它们主要的功能是提供数据的访问和处理，可以从数据库中获取数据、进行数据修改、通过控制器向视图提供数据等等。这些模型类是 MVC 设计模式中 Model 层的一部分，即数据访问层或数据模型层。除此之外，可能还会包含一些用于数据访问和处理的辅助类，例如数据库上下文类、数据访问对象（DAO）类、业务逻辑处理类等等。

Scripts： 包含项目需要使用的 JavaScript 文件。这些文件包括 jQuery、Bootstrap 等库和插件，以及项目自定义的 JavaScript 文件。在视图页面中需要用到 JavaScript 时，可以通过引入 Scripts 文件夹中的脚本来实现。

Views： 用于存放视图页面的文件夹。每个控制器都有一个匹配的视图页面文件夹，该文件夹与控制器同名。例如，名为 HomeController 的控制器将包含名为 Home 的视图文件夹。在这个文件夹里存放的是用于呈现数据模型的视图页面，可以包含 HTML、CSS、JavaScript等内容，用于呈现和渲染用户界面。在 Views 文件夹中包含了 cshtml 文件，这些是视图模板文件，定义了如何呈现数据模型和控件的组合。

![image-20230809113834264](D:\stu\java\java markdown\image\image-20230809113834264.png)

2.3、配置文件

favicon.ico： 是为网站添加图标的文件。Favicon 是" Favorites icon "的缩写，也称为网站图标或书签图标。当用户收藏网站或将网站添加到书签时，浏览器会显示该图标。此外，在浏览器地址栏和标签上也会显示该图标，用于标识网站。
Global.asax： 是一个 ASP.NET 应用程序的全局文件，它可以实现应用程序级别的事件处理程序。当应用程序启动时，该文件负责初始化应用程序配置和全局设置。在 Global.asax 文件中可以添加应用程序级别的事件处理程序，例如应用程序的开始、结束、错误处理等等。
![image-20230809114904350](D:\stu\java\java markdown\image\image-20230809114904350.png)

- **packages.config：** 用于记录管理项目中**所有 NuGet 包的详细信息的文件**，包括名称、版本、依赖项等信息。NuGet 是用于 .NET 平台的包管理器，通过 NuGet 可以方便地找到、安装、卸载和管理第三方库和工具。

![image-20230809114933702](D:\stu\java\java markdown\image\image-20230809114933702.png)

Web.config： 是一个 XML 格式的配置文件，其中包含了网站部署所需的所有设置和选项。在 Web.config 文件中，可以定义与应用程序有关的各种设置，包括连接字符串、验证模式、HTTP 模块、错误处理、会话状态、缓存设置等等。此外，Web.config 文件还允许开发者定制网站功能，并提供了一些高级功能的配置选项，例如 ASP.NET 管道和 HTTP 处理程序的配置。Web.config 文件是 ASP.NET MVC 项目中非常重要的一部分，可以帮助开发者有效地管理和控制网站的访问和行为。
![image-20230809115224213](D:\stu\java\java markdown\image\image-20230809115224213.png)

## 和.net core 的区别

- **The .NET Framework**  这个是我们现在经常用的，用这个可以创建windows应用程序还有web applications ，现在你可以用它创建Winform ，UWP ,wpf 等等相关的应用程序 ，web 方面就是Asp.net MVC
- **.NET Core**  是微软推出的最新的开源的，跨平台的框架，用它可以创建的应用可以运行在MAC，Linux上 。 .net core  支持UWP 和 ASP.NET Core，UWP即Windows 10 中的Universal Windows Platform简称。即Windows通用应用平台，在Win 10 Mobile/Surface(Windows平板电脑）/PC/Xbox/HoloLens等平台上运行，uwp不同于传统pc上的exe应用也跟只适用于手机端的app有本质区别。它并不是为某一个终端而设计，而是可以在所有windows10设备上运行。

## ado.net

ado.net 是.net 框架的一个组件， 主要用于访问数据库，提供了对关系数据、XML 和应用程序数据的访问,ADO（ActiveX Data Objects）



![image-20240513152620369](D:\stu\java\java markdown\image\image-20240513152620369.png)

### 相关的类

https://www.cnblogs.com/yangcaogui/archive/2012/06/09/2537086.html#3

```
①System.Data  → DataTable，DataSet，DataRow，DataColumn，DataRelation，Constraint，DataColumnMapping，DataTableMapping
②System.Data.Coummon     → 各种数据访问类的基类和接口
③System.Data.SqlClient   → 对Sql Server进行操作的数据访问类
  主要有：   a) SqlConnection            → 数据库连接器
            b) SqlCommand               → 数据库命令对象
            c) SqlCommandBuilder        → 生成SQL命令
            d) SqlDataReader            → 数据读取器
            e) SqlDataAdapter           → 数据适配器，填充DataSet
            f) SqlParameter             → 为存储过程、sql定义参数，SqlCommand添加参数通过SqlParameter
            g) SqlTransaction           → 数据库事务
```

对于mysql，oracle，数据对象不变，其他类在前面加上Mysql,如MysqlConnection，OracleCommand.

oracle的包是Oracle.DataAccess.dll，mysql的包是Mysql.Data.dll

#### 数据对象

DataTable，DataSet，DataRow，DataColumn，DataRelation，Constraint，DataColumnMapping，DataTableMapping

表示数据存放在缓存中，DataSet里面可以包含多个DataTable，DataTable中有多个DataColumn和多个DataRow，包括对各种对DataTable的操作，以及对列和行的操作，在进行DataSet,DataTable进行操作的时候，应该先判断它们是否为Null，这是最基本的!

**1.DataTable，DataRow，DataColumn**

　　　　①创建自己的DataTable 

```
 1 DataTable dt = new DataTable("Table");
 2 DataColumn columnName = new DataColumn();
 3 columnName.ColumnName = "Name";
 4 //columnName.DataType = typeof(string);
 5 //注意和上面一句话的比较
 6 columnName.DataType = Type.GetType("System.String");
 7 columnName.DefaultValue = "YangCaoGui";
 8 dt.Columns.Add(columnName); //DataColumnCollection的集合
 9 DataRow row = dt.NewRow(); //使用NewRow方法来实例化一个行
10 row[columnName] = "WangWei"; //采用索引的方式有很多
11 dt.Rows.Add(row);  //DataRowCollection的集合
12 Console.WriteLine("Type: " + dt.Columns[0].DataType.Name);
```

　　　　②使用对象集合初始化器简化代码，以及使用“DataColumnCollection”和“DataRowCollection”来操作已添加的行和列

　　　　构造函数的访问修饰符为Internal，通过这两个集合可以对Column和Row进行“增，删，改，查”，如Remove，Add，RemoveAt 

```
 1 dt.Columns.Add(new DataColumn("Age", typeof(Int32)));
 2 dt.Columns.Add(new DataColumn()
 3 {
 4     ColumnName = "Address",
 5     DataType = typeof(string),
 6     DefaultValue = "江苏海安"
 7 });
 8 //我们这边使用Add的方法的第二个重载
 9 dt.Rows.Add(new object[] {"11", 44, "222", "yang cao gui"});
10 //我们也可以对添加好的行和列进行读取和修改
11 dt.Columns[0].ColumnName = "wang wei";
12 dt.Rows[0]["wang wei"] = "我把这行这列的值修改了，哈哈";
```

　　　　③使用表达树快速构建自己的列

```
 1       public static void DataTableExpression()
 2        {
 3            DataTable dt = new DataTable("Table");
 4            DataColumn price = new DataColumn("price", typeof(Int32));
 5            DataColumn number = new DataColumn("number", typeof(Int32));
 6            dt.Columns.Add(price);
 7            dt.Columns.Add(number);
 8            for (int i = 1; i <= 5; i++)
 9            {
10                DataRow newRow = dt.NewRo();                           
11                newRow["price"] = i;
12                newRow["number"] = i + 5;
13                dt.Rows.Add(newRow);
14            }
15            //显示表数据
16         for (int i = 0; i < dt.Rows.Count; i++)
17            {
18                Console.WriteLine("Price: {0} , Number：{1}", dt.Rows[i]["price"], dt.Rows[i]["number"]);
19            }
20            //使用Expression来定制自己的Table
21            Console.WriteLine("-----------------------------------");
22            DataColumn total = new DataColumn("total", typeof(Int32));
23            dt.Columns.Add(total);
24           //可以使用这样的方式来定制自己DataTable                       
25           dt.Columns["total"].Expression = "price * number";  
26            //显示定制后的数据
27 
28        Console.WriteLine("显示数据");
29 
30            for (int i = 0; i < dt.Rows.Count; i++)
31            {
32                Console.WriteLine("Price: {0} , Number：{1} ，Total：{2}", dt.Rows[i]["price"], dt.Rows[i]["number"], dt.Rows[i]["total"]);
33            }
34        }
```

#### Connection连接对象

Connection对象也称为数据库连接对象，Connection对象的功能是负责对数据源的连接。所有Connection对象的基类都是DbConnection类。 

##### 连接字符串

基本语法：数据源(Data Source)+数据库名称(Initial Catalog)+用户名(User ID)+密码(Password)

1.1、SQL Server连接字符串

标准安全连接： 

Data Source=.;Initial Catalog=myDataBase;User Id=myUsername;Password=myPassword;或者

Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;Trusted_Connection=False;

可信连接：

Data Source=myServerAddress;Initial Catalog=myDataBase;Integrated Security=SSPI;或者

Server=myServerAddress;Database=myDatabase;Trusted_Connection=True; 

1.2、Access连接字符串

Provider=Microsoft.Jet.OLEDB.4.0;Data Source=C:\myDatabase.mdb;User Id=admin;Password=;

1.3、MySQL连接字符串

Server=myServerAddress;Database=myDatabase;Uid=myUsername;Pwd=myPassword;

1.4、DB2连接字符串

Server=myAddress:myPortNumber;Database=myDatabase;UID=myUsername;PWD=myPassword;

1.5、Oracle连接字符串

Data Source=TORCL;User Id=myUsername;Password=myPassword; 

在VS中获得连接字符串并连接到数据库：

工具->连接到数据库（没有mysql?）



1.6 、在配置文件写连接字符串

```
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
    </startup>
    <connectionStrings>
      <add name="MySqlConnString" connectionString="Server =localhost; Database =test; Uid =***; Pwd =***;Pooling=true; Max Pool Size=20;Min Pool Size=10;Allow Batch=true;" providerName="MySql.Data.MySqlClient" />
    </connectionStrings>
</configuration>
```



可以使用ConfigurationManager.ConnectionStrings属性来访问这个连接字符串:

string connectionString = ConfigurationManager.ConnectionStrings["MyDbConnectionString"].ConnectionString;

没有测试成功，新版本读取json文件，使用其他的类。

##### 使用using不需要释放连接

继承IDisposable接口，使用using释放连接

```
//使用using，相当于使用了try{}finally{using括号的对象的Dispose(即释放对象)}
using (MySqlConnection connection = new MySqlConnection(_connectionString))
{
    try
    {
        connection.Open();
    }
    catch (MySqlException)
    {
        MessageBox.Show("数据库读取失败，本数据库的设置是：\n" +
  "server=localhost;Port=3306;User Id=root;database=test;password=root;Charset=utf8");
  		//不需要调用connection.Close();
    }

}
```



#### Command对象

Command对象也称为数据库命令对象，Command对象主要执行包括添加、删除、修改及查询数据的操作的命令。也可以用来执行存储过程。用于执行存储过程时需要将Command对象的CommandType 属性设置为CommandType.StoredProcedure，默认情况下CommandType 属性为CommandType.Text，表示执行的是普通SQL语句。
Command主要有三个方法： 

**ExecuteNonQuery()：**执行一个SQL语句，返回受影响的行数，这个方法主要用于执行对数据库执行增加、更新、删除操作，注意查询的时候不是调用这个方法。用于完成insert，delete，update操作。

**ExecuteScalar ()**从数据库检索单个值。这个方法主要用于统计操作。ExecuteScalar ()这个方法是针对SQL语句执行的结果是一行一列的结果集，这个方法只返回查询结果集的第一行第一列。executeScalar主要用于查询单行单列的值，如聚合函数（count,max,min,agv,sum）。**Scalar**标量的

```
//将执行的sql
                String sql = "select COUNT(*) from Car";
                //创建命令对象，指定要执行sql语句与连接对象conn
                SqlCommand cmd = new SqlCommand(sql, conn);
                //执行查询返回单行单列的值，Object类型
                Object result = cmd.ExecuteScalar();
                //显示结果到标签
                lblCount.Text = result.ToString();
```

ExecuteReader用于实现只进只读的高效数据查询。

ExecuteReader：返回一个SqlDataReader对象，可以通过这个对象来检查查询结果，它提供了只进只读的执行方式，即从结果中读取一行之后，移动到另一行，则前一行就无法再用。有一点要注意的是执行之后，要等到手动去调用Read()方法之后，DataReader对象才会移动到结果集的第一行，同时此方法也返回一个Bool值，表明下一行是否可用，返回True则可用，返回False则到达结果集末尾。

使用DataReader可以提高执行效率，有两种方式可以提高代码的性能：

一种是基于序号的查找

一个是使用适当的Get方法来查找。因为查询出来的结果一般都不会改变，除非再次改动查询语句，因此可以通过定位列的位置来查找记录。用这种方法有一个问题，就是可能知道一列的名称而不知道其所在的位置，这个问题的解决方案是通过调用DataReader 对象的GetOrdinal()方法，此方法接收一个列名并返回此列名所在的列号。

```
//创建连接对象，并使用using释放（关闭），连接用完后会被自动关闭
            using (SqlConnection conn = new SqlConnection("server=.;uid=sa;pwd=sa;database=MyCar"))
            {
                //打开连接
                conn.Open();
                //将执行的sql
                String sql = "select Id,Title,Speed,Info from Car";
                //创建命令对象，指定要执行sql语句与连接对象conn
                SqlCommand cmd = new SqlCommand(sql, conn);
                //执行查询返回结果集
                SqlDataReader sdr = cmd.ExecuteReader();
                //下移游标，读取一行，如果没有数据了则返回false
                while (sdr.Read())
                {
                    Console.WriteLine("编号：" + sdr["Id"] + "，车名：" + sdr["Title"] + "，速度：" + sdr["Speed"]);
                }
            }
```

#### SqlParameter

作用：如果不采用SqlParameter，那么当输入的Sql语句出现歧义时，如字符串中含有单引号，经典例子“or ‘1=1’”永真式，有可能sql语句被截断，容易被黑客注入攻击，更有的甚至会导致你的数据库崩溃。

```
string sql = "insert into out_in_storage(day_night_shift,record_acc," +
                "record_name,handle_acc,handle_name,is_outed,product_line,fixure_id,log_time) " +
                "values(@day_night_shift,@record_acc,@record_name,@handle_acc,@handle_name,@is_outed," +
                "@product_line,@fixure_id,@log_time)";
            SqlParameter[] parameters = {
            new SqlParameter("@day_night_shift","day"),
            new SqlParameter("@record_acc", "123"),
            new SqlParameter("@record_name", "张飞"),
            new SqlParameter("@handle_acc", "2"),
            new SqlParameter("@handle_name", "operator"),
            new SqlParameter("@is_outed", 1),
            new SqlParameter("@product_line", "1"),
            new SqlParameter("@fixure_id", "2"),
            new SqlParameter("@log_time", "2019/2/18")
            };
SqlCommand cmd = new SqlCommand(sql, conn);
cmd.Parameters.AddRange(parameters);
```

其中add（）是每次只能添加一个SqlParameter，还有addRange（）能同时添加多个SqlParameter。

使用SQLparameter时要注意一点，在前面定义string类型字符串时，对于数据库中varchar类型的数据不需要再添加单引号！！！

//下面定义的字符串是错误的，需要将@fixure_id两边的单引号删去，才是正确的写法
string sqlValue = "update fixure_entity set entity_status_id=2 where fixure_id='@fixure_id'";

SQLparameter使用时还有一个注意点：SqlParameter如果传入0会变成NULL
错误测试代码：

SqlParameter parm = new SqlParameter("@id",0);
调试时候发现@id值变成null，无法正确调用。

正确写法：

SqlParameter parm = new SqlParameter("@id",Convert.ToInt32(0));

#### SqlDataReader

缺点：不灵活，只适合数据小的情况，一直占用连接

见前面例子

#### SqlDataAdapter

SqlDataAdapter(数据适配器)

fill填充数据 ，update把DataSet中表和数据库进行对比，更新

**1.构造函数** 

```
1 四个重载：    
2   1. 无参
3   2. SqlDataAdapter(SqlCommand)  → 执行命令对象实例
4   3. SqlDataAdapter(String, SqlConnection) → ①只能指定查询语句 ②连接对象实例
5   4. SqlDataAdapter(String, ConnectionString) → 用 SelectCommand 和一个连接字符串初始化 SqlDataAdapter 类的一个新实例
6   Note：第四个重载就把连接对象和命令对象都包含进去了！
```

最简单的填充数据 

```
1 DataSet dataSet = new DataSet();
2 using (SqlConnection conn = new SqlConnection(""))
3 {
4     conn.Open();
5     SqlCommand command = conn.CreateCommand();
6     command.CommandText = "select name,age,address from MyInformation";
7     SqlDataAdapter dataAdapter = new SqlDataAdapter(command);
8     dataAdapter.Fill(dataSet);  //填充数据
9 }
```

**3.使用“SqlCommandBuilder”对数据进行增删改查**

 　　　①添加数据

```
 1  using (SqlConnection conn = new SqlConnection(ConnectionString()))
 2  {
 3      conn.Open();
 4      //构建查询语句，也可以指定SqlCommand，其中变换的方法有很多
 5      SqlDataAdapter da = new SqlDataAdapter("select LastName,FirstName from dbo.Employees", conn);
 6      DataSet ds = new DataSet();
 7      da.Fill(ds);
 8      //这句话很重要，它会把你在DataSet增加的数据转化为SQL语句用来更新数据库
 9      SqlCommandBuilder cmdBuilder = new SqlCommandBuilder(da);
10      //添加行，实例化一个行对象，注意是用NewRow来创建行
11      DataRow row = ds.Tables[0].NewRow();
12      row[0] = "Yang";
13      row[1] = "鬼头";
14      ds.Tables[0].Rows.Add(row);  //添加到表中
15      da.Update(ds);             //把DataSet中表和数据库进行对比，更新
16  }
```

 　　　②修改数据

```
 1 using (SqlConnection conn = new SqlConnection(""))
 2 {
 3     SqlDataAdapter da = new SqlDataAdapter("SQL语句或你自己定义的命令对象", conn);
 4     DataSet ds = new DataSet();
 5     da.Fill(ds);
 6     //很重要的一句话
 7     SqlCommandBuilder cmdBuilder = new SqlCommandBuilder(da);
 8     ds.Tables[0].Rows[12][1] = ""; //修改数据
 9     da.Update(ds);
10     //调用Update方法其中隐式的调用了AcceptChanges方法，更新数据集中的数据
11     //如果你继续使用这个数据集而没有调用这个方法，在后面的使用会出现异常
12     ds.AcceptChanges();  //这句话可以不写的
13 }
```

　③删除数据

```
 1  using (SqlConnection conn = new SqlConnection(""))
 2  {
 3      SqlDataAdapter da = new SqlDataAdapter("SQL语句或你自己定义的命令对象", conn);
 4      DataSet ds = new DataSet();
 5      da.Fill(ds);
 6      SqlCommandBuilder cmdBuilder = new SqlCommandBuilder(da);
 7      //删除数据
 8      ds.Tables[0].Rows[12].Delete();
 9      da.Update(ds);  //这边会隐式调用DataTable的AcceptChanges方法
10  }
```

 **Note(很重要的注意点)**：值得注意的是Update方法已经隐式帮我调用了AcceptChanges，不比担心状态为改变删除数据会报错

关于“SqlDataAdapter”中Fill方法

```
1 ★指定填充数据的数量，如：
2 //从第五行到第十行数据填充DataSet   
3 //上面的定义错了
4 //应该是从第六行开始，后面的十条记录
5 da.Fill(ds,5,10,”MyTable”) 
```

**DataRowState(行状态)，DataRowVersion(行版本)**

①DataRowState(行状态)是“DataRow”中一个很重要的状态，主要有五个方面：

```
1     Added          → 添加  添加后没有AcceptChanges
2     Deleted        → 删除
3     Detached       → 分离  创建后没有加入DataRowCollection,或者从集合中移除
4     Modified       → 修改
5     Unchanged      → 未改变 AcceptChanges后
```

②DataRowVersion(行版本)，有四个版本状态，如下：

```
1     Current     → 最近的行，主要针对Deleted操作之前的行，行状态的Deleted
2     Default     → 行的默认状态
3     Original    → 行的原始值 Added，Modified，Unchanged    
4     Proposed    → 行的建议值 
```

![img](D:\stu\java\java markdown\image\2012060916454093.png)

**DataSet，DataTable**

　　　　比较重要的方法：Select,Merge,Copy,Clone,GetChanges等等

　　　　关于GetChanges方法：获取数据改变的地方，它所获取的是你上次调用AcceptChanges方法之后修改数据的信息。 

**“DataRelation”和“DataView”的知识也很重要** 

　　　　DataView **→** 表示用于排序、筛选、搜索、编辑和导航的 DataTable的可绑定数据的自定义视图

　　　　DataRelation **→** 表示两个 DataTable 对象之间的父/子关系

在App.Config添加连接字符串

```
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
    </startup>
    <connectionStrings>
      <add name="MySqlConnString" connectionString="Server =localhost; Database =test; Uid =***; Pwd =***;Pooling=true; Max Pool Size=20;Min Pool Size=10;Allow Batch=true;" providerName="MySql.Data.MySqlClient"/>
    </connectionStrings>
</configuration>
```

安装MySql.Data 包

注意:MySQL的操作跟1的介绍是一模一样，只是要在前面加MySql，如MySqlConnection,MySqlCommand等等

特别的是DataSet/DataTable并不要在前面加MySql。

```
using MySql.Data.MySqlClient;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MyfirstApp
{
    public partial class Form2 : Form
    {

        MySqlDataAdapter mysqlAdapter = new MySqlDataAdapter();
        DataTable dt = new DataTable();
        private static string _connectionString = string.Format("server={0};Port={1};User Id={2};database={3};password={4};Charset=utf8",
                         "192.168.71.134", 3306, "root", "mall", "root");
        public Form2()
        {
            string sqlString = string.Format("select count(*) from {0}", "pms_brand");
            //使用using，相当于使用了try{}finally{using括号的对象的Dispose(即释放对象)}
            System.Console.WriteLine("query1:"+ExcuteSQL(sqlString, 1));
            InitializeComponent();
        }

        private void Form2_Load(object sender, EventArgs e)
        {


            string sqlString = string.Format("select  * from {0}", "pms_brand");
            //使用using，相当于使用了try{}finally{using括号的对象的Dispose(即释放对象)}
            using (MySqlConnection connection = new MySqlConnection(_connectionString))
            {
                try
                {
                    connection.Open();
                    //MySqlDataAdapter获取数据库，可以断Connection
                    mysqlAdapter.SelectCommand = new MySqlCommand(sqlString, connection);
                    //MySqlDataAdapter填充到DataTable，即dt获取数据库所有的行
                    mysqlAdapter.Fill(dt);
                    foreach (DataRow row in dt.Rows)
                    {
                        //输出表的name列的值
                        System.Console.WriteLine(Convert.ToString(row["name"]));
                    }

                }
                catch (MySqlException)
                {
                    MessageBox.Show("数据库读取失败，本数据库的设置是：\n" +
              "server=localhost;Port=3306;User Id=root;database=test;password=root;Charset=utf8");
                }
            
            }
        }

        public int ExcuteSQL(string sqlString, int flag)
        {
            int n;
            using (MySqlConnection connection = new MySqlConnection(_connectionString))
            {
                //第二种操作数据库的方式是使用MySqlCommand。第一种是使用了MysqlDataAdapter来操作。
                using (MySqlCommand cmd = new MySqlCommand())
                {
                    try
                    {
                        cmd.Connection = connection;
                        cmd.CommandType = CommandType.Text;
                        cmd.CommandTimeout = 0;
                        cmd.CommandText = sqlString;
                        connection.Open();
                        //flag=0表示增删改的操作，否则就是查询。语句是不一样的，你们可以查ExecuteNonQuery()和ExecuteScalar()的不同
                        if (flag == 0)
                            n = Convert.ToInt32(cmd.ExecuteNonQuery());
                        else
                            n = Convert.ToInt32(cmd.ExecuteScalar());
                        return n;
                    }
                    catch (MySqlException)
                    {
                        MessageBox.Show("数据库读取失败，本数据库的设置是：\n" +
                "server=localhost;Port=3306;User Id=root;database=test;password=root;Charset=utf8");
                        return 0;
                    }
                }
            }
        }

    }
}

```



##### 和SqlDataReader对比

|          | SqlDataReader            | 适配器           |
| -------- | ------------------------ | ---------------- |
| 性能     | 快                       | 慢               |
| 数据量   | 小                       | 大               |
| 内存     | 小                       | 大               |
| 连接     | 一直占用                 | 断开与连接       |
| 读取方式 | 从头读到尾，读一条丢一条 | 一次性加载到内存 |
| 是否可读 | 只读                     |                  |



### 连接池

Ado.net默认启动连接池,以下命令关闭连接池

Server=myServerAddress;Database=myDatabase;Uid=myUsername;Pwd=myPassword;Max Pool Size = 5;Pooling=false

#### 1 创建连接池

需要说明的是，**连接池是具有类别区分的。**也就是说，同一个时刻同一应用程序域可以有多个不同类型的连接池。那么，连接池是如何标识区分的？细致的讲，是由进程、应用程序域、连接字符串以及windows标识（在使用集成的安全性时）共同组成签名来标识区分的。但对于同一应用程序域来说，一般只由连接字符串来标识区分。当打开一条连接时，如果该条连接的类型签名与现有的连接池类型不匹配，则创建一个新的连接池。反之，则不创建新的连接池。

   一个典型的创建连接的实例：

```
//创建连接对象1
using (SqlConnection conn1 =

             new SqlConnection(  "DataSource=(local);Integrated Security=SSPI;Initial Catalog=Northwind"))    
{        
    conn1.Open();       
}


//创建连接对象2
using (SqlConnection conn2 =

           new SqlConnection(  "DataSource=(local);Integrated Security=SSPI;Initial Catalog=pubs"))   
{       
    conn2.Open();      
}


//创建连接对象3
using (SqlConnection conn3 =

         new SqlConnection(  "DataSource=(local);Integrated Security=SSPI;Initial Catalog=Northwind"))  
{        
    conn3.Open();      
} 
```

上面实例中，我创建了三个SqlConnection对象，但是管理时只需要两个连接池。细心的朋友，可能早已发现**conn1与conn3的连接字符串相同，所以可以共享一个连接池，而conn2与conn1与conn3不同，所以需要创建新的连接池。**

#### 2 分配空闲连接

   当用户创建连接请求或者说调用Connection对象的Open时，**连接池管理器首先需要根据连接请求的类型签名找到匹配类型的连接池，然后尽力分配一条空闲连接。**具体情况如下：

- 如果池中有空闲连接可用，返回该连接。
- 如果池中连接都已用完，创建一个新连接添加到池中。
- 如果池中连接已达到最大连接数，请求进入等待队列直到有空闲连接可用。

#### 3 移除无效连接 

   无效连接，即不能正确连接到数据库服务器的连接。对于连接池来说，存储的与数据库服务器的连接的数量是有限的。因此，对于无效连接，如果如不及时移除，将会浪费连接池的空间。其实你不用担心，连接池管理器已经很好的为我们处理了这些问题。如果连接长时间空闲，或检测到与服务器的连接已断开，连接池管理器会将该连接从池中移除。

#### 4 回收使用完的连接

   **当我们使用完一条连接时，应当及时关闭或释放连接，以便连接可以返回池中重复利用。**我们可以通过Connection对象的Close或Dispose方法，也可以通过C#的using语句来关闭连接。

#### 5. 重要属性

**连接池的行为可以通过连接字符串来控制**，主要包括四个重要的属性：

- **Connection Timeout：**连接请求等待超时时间。默认为15秒，单位为秒。
- **Max Pool Size:** 连接池中最大连接数。默认为100。
- **Min Pool Size:** 连接池中最小连接数。默认为0。
- **Pooling:** 是否启用连接池。**ADO.NET默认是启用连接池的，**因此，你需要手动设置Pooling=false来禁用连接池。

代码如下：

```
SqlConnectionStringBuilder connStr = new SqlConnectionStringBuilder();
            connStr.DataSource = @".\SQLEXPRESS";
            connStr.InitialCatalog = "master";
            connStr.IntegratedSecurity = true;

            connStr.Pooling = true; //开启连接池
         connStr.MinPoolSize = 0; //设置最小连接数为0
            connStr.MaxPoolSize = 50; //设置最大连接数为50             
            connStr.ConnectTimeout = 10; //设置超时时间为10秒

            using( SqlConnection conn = new SqlConnection(connStr.ConnectionString))
            {
                ;//todo
            }
```

# winform窗体



 WinForm 是 Windows Form 的简称，是基于 .NET Framework 平台的客户端（PC软件）开发技术，一般使用 C# 编程。在VS2019中，C# WinForm 编程需要创建「Windows窗体应用程序」项目。

### 生成exe文件

https://blog.csdn.net/zgscwxd/article/details/135198115

# 其他

## StopWatch检查执行时间

Stopwatch sw1 = new Stopwatch();

sw1.start();

检查的执行代码

sw1.stop();

sw1.ElapsedMilliseconds 耗时毫秒

# 开源项目：

**1、DotNetFramework** 

[.NET Reference Source](http://referencesource.microsoft.com/) 发布了 [beta](http://referencesource-beta.microsoft.com/) 版，可以在线浏览 .NET Framework 4.5.1 的源代码，并且可以通过配置，[在 Visual Studio 2013 中调试 .NET Framework](http://referencesource-beta.microsoft.com/setup.html)。

项目地址：[Reference Source](http://referencesource.microsoft.com/)

**2、Mvc**

MVC 就不用说，很强大。

项目网址：[aspnet/Mvc 路 GitHub](https://github.com/aspnet/Mvc)

**3、Entity Framework**

[http://ADO.NET](http://ado.net/) Entity Framework 是微软以 [http://ADO.NET](http://ado.net/) 为基础所发展出来的对象关系对应 (O/R Mapping) 解决方案，早期被称为 ObjectSpace，现已经包含在 Visual Studio 2008 Service Pack 1 以及 .NET Framework 3.5 Service Pack 1 中发表。
项目网址：[aspnet/EntityFramework 路 GitHub](https://github.com/aspnet/EntityFramework)

**4、Enterprise Library**

Enterprise Library 是 patterns & practices 小组为.NET Framework 开发一套企业库，目前最新版本为 v5.0，支持.NET Framework 4.0，共包括 9 个 Application Block，包括数据访问（Data Access Application Block）、异常管理（Exception Handling Application Block）、数据验证（Validation Application Block）等等，对企业应用开发非常有帮助，也非常实用。

项目网址：[Enterprise Library](http://msdn.microsoft.com/library/cc467894.aspx)

Codeplex：[patterns & practices](http://entlib.codeplex.com/)

**5、NopCommerce** 

nopcommerce 是国外的一个高质量的开源 b2c 网站系统，基于 EntityFramework4.0 和 MVC3.0，使用 Razor 模板引擎，有很强的插件机制，包括支付配送功能都是通过插件来实现的，基于 xml 的多语言版本，非常灵活的语言切换功能，包括在后台都能同时编辑产品的中英文属性，非常适合做外贸，优秀超前的程序架构，性能也非常强大，自定义的产品名称和分类又有很好的 seo 优化。综合能力远远高于国内的一些程序架构糟糕的.net 商城程序，是二次开发和大型 b2c 架构的首选。3.0 开始支持多店。

项目网址：[nopCommerce - ASP.NET Open-source Ecommerce Shopping Cart Solution](http://www.baidu.com/link?url=JsVe3FvH50hsAfTQ8ccrdo5-UE-pM6SVpH3GxDuY0577qXWmOx0N6bNt9IwCIOou)

**7、Orchard**

Orchard 是一个以微软为主导的开源 CMS 项目，它允许使用者在.Net 平台上快速建立网站，并且提供扩展框架能够允许定制人员通过模块和主题等增加额外的内容，Orchard 能够建设出复杂的内容管理系统，它提供了强大的模块化建设模式，通过组件的重用将系统建设成本最小化，帮助用户减少编码，从而吸引非技术人员的关注。

项目地址：[Orchard](http://www.orchardproject.net/)

1. CoreShop: 是 .NET 第一国产电商项目，影响力最大。其核心商城系统是基于 Asp.NET 5.0、Uni-App 开发，支持可视化布局的小程序商城系统。它前后端分离，支持分布式部署，跨平台运行。同时拥有分销、代理、团购秒杀、接龙、拼团、直播、优惠券、自定义表单等众多营销功能，并且拥有完整 SKU、下单、售后、物流流程，支持可视化自定义首页模块布局效果。
2. RuYiAdmin: 是一款前后端分离的、代码能够自动生成的、基于 .Net6 的、可以跨平台的、低代码、分布式 RBAC Web 后台管理系统模板，支持系统集成与统一认证。



